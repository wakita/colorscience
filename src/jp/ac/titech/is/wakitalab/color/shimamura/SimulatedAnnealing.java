/* * 作成日: 2004/07/01 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.*;/** * @author shinamu1 */public class SimulatedAnnealing {		/**	 * コントロールフラグ	 */	boolean jumpDichroWorld = false;		/**	 * 収束履歴について、GNU PLOT 用の出力を残すかどうか	 */	boolean plotting = true;		/**	 * 色の個数	 */	int n;		/**	 * 色盲タイプ	 */	int type;	/**	 * 願望	 */	CompoundDesire compDesire;		/**	 * 現在の色	 */	Lab[] nowLabs;		/**	 * 現在の色盲の色	 */	Lab[] nowDichroLabs;		/**	 * 一時的な変換用のオブジェクト。	 * 変換が二重に起こるとバグになります。	 * TODO（解決策：ロック変数を作る。）	 */	final static LMS preDichroLMS = new LMS();	final static LMS dichroLMS = new LMS();	final static double[] values = new double[3];	Lab[] newLabs, newDichroLabs;	LMS[] nextDLmss;	SRGB forStartSRGB = new SRGB();			SRGBdash[] anchor = new SRGBdash[4];	SRGBdash centerAnchor = new SRGBdash();	double[] a = new double[3], b = new double[3], c = new double[3];	SRGBdash preDichroSRGBdash = new SRGBdash();	SRGBdash nextDichroSRGBdash = new SRGBdash();		/**	 * 各色を固定して、不動とするフラグ	 */	boolean[] fixColoring;	/**	 * 出力ストリーム	 */	FileWriter[] fw;	BufferedWriter[] bw;	static int plotNum = 0;			/************************************************************	 *							初期化							*	 ************************************************************/		/**	 * SRGBを使った色の固定をするコンストラクター	 * @param compDesire	 * @param firstSRGB	 * @param fixColoring	 * @param dType	 */	public SimulatedAnnealing(CompoundDesire compDesire, SRGB[] firstSRGB, boolean[] fixColoring, int dType) {		initialize(compDesire, dType);		this.fixColoring = fixColoring;		for (int i=0;i<n;i++) {			firstSRGB[i].getLab(nowLabs[i]);			Dichromat.convert(nowLabs[i], nowDichroLabs[i], dType);		}	}		/**	 * LMSを使った色の固定をするコンストラクター	 * @param compDesire	 * @param firstLMS	 * @param fixColoring	 * @param dType	 */	SimulatedAnnealing(CompoundDesire compDesire, LMS[] firstLMS, boolean[] fixColoring, int dType) {		initialize(compDesire, dType);		this.fixColoring = fixColoring;		for (int i=0;i<n;i++) {			firstLMS[i].getLab(nowLabs[i]);			Dichromat.convert(nowLabs[i], nowDichroLabs[i], dType);		}	}		/**	 * Labを使った色の固定をするコンストラクター	 * @param compDesire	 * @param firstLab	 * @param fixColoring	 * @param dType	 */	SimulatedAnnealing(CompoundDesire compDesire, Lab[] firstLab, boolean[] fixColoring, int dType) {		initialize(compDesire, dType);		this.fixColoring = fixColoring;		for (int i=0;i<n;i++) {			nowLabs[i].setVector3d(firstLab[i]);			Dichromat.convert(nowLabs[i], nowDichroLabs[i], dType);		}	}		/**	 * 色の固定はしないコンストラクター	 * @param compDesire	 * @param dType	 */	SimulatedAnnealing(CompoundDesire compDesire, int dType) {		initialize(compDesire, dType);		fixColoring = new boolean[n];		for (int i=0;i<n;i++) 			fixColoring[i] = false;	}		/**	 * 色の固定と初期色の設定、を除く初期化部。	 * 次元 n などもここで設定。	 * なので、コンストラクター内では早めに呼ぶこと。	 * @param compDesire	 * @param dType	 */	private void initialize(CompoundDesire compDesire, int dType) {		this.compDesire = compDesire;		n = compDesire.dimension();		this.type = dType;		nowLabs = new Lab[n];		nowDichroLabs = new Lab[n];//TODO いつも使うようでなければ、使用時にnullなら初期化する形に。		newLabs = new Lab[n];		newDichroLabs = new Lab[n];		nextDLmss = new LMS[n];		for (int i=0;i<n;i++) {			nowLabs[i] = new Lab();			nowDichroLabs[i] = new Lab();			newLabs[i] = new Lab();			newDichroLabs[i] = new Lab();			nextDLmss[i] = new LMS();		}		for (int i=0;i<4;i++) anchor[i] = new SRGBdash();	}		/************************************************************	 *						ジャンプ関数						*	 ************************************************************/		/**	 * Lab ランダムジャンプ 色固定可能	 * @param preLabs : input values	 * @param nextLabs : output values	 * @param nextDichroLabs : output values	 */	private void jumpLab(Lab[] preLabs, Lab[] nextLabs, Lab[] nextDichroLabs, double jump) {		for (int i=0;i<n;i++) {			if (!fixColoring[i]){				preLabs[i].getDoubles(values);				for (int j=0;j<3;j++) {					values[j] += (2.0*Math.random()-1.0) * jump;				}				nextLabs[i].setValue(values[0], values[1], values[2]);				nextLabs[i].boundaryReviseSRGBdash();				nextLabs[i].getLMS(preDichroLMS);				Dichromat.convert(preDichroLMS, dichroLMS, type);				dichroLMS.getLab(nextDichroLabs[i]);			}		}	}		/**	 * ランダムに色 lab をジャンプさせ newLab に代入	 * 境界補正も行う	 * @param lab	 * @param newLab	 * @param jump １次元あたりの最大ジャンプ距離	 */	void jump (Lab lab, Lab newLab, double jump) {		lab.getDoubles(values);		for (int i=0;i<3;i++) {			values[i] += (2.0*Math.random()-1.0) * jump;			newLab.setValue(i, values[i]);		}		newLab.boundaryReviseSRGBdash();	}		/**	 * 色盲Labの色から、次の色盲Labの色へのジャンプを行う。	 * SRGBdash空間に落として行う。	 * @param preDichroLabs	 * @param nextDichroLabs	 */	private void jumpDichroPlaneSRGB(Lab[] preDichroLabs, Lab[] nextDichroLabs, double jump) {				for (int i=0;i<preDichroLabs.length;i++) {			if (!fixColoring[i]) {//色i を固定する場合を除き、以下を実行する								//現在の色盲の色をSRGBdashに変換する。				preDichroLabs[i].getSRGBdash(preDichroSRGBdash);				preDichroSRGBdash.getDoubles(values);								//SRGBdash空間のRG平面でランダムジャンプ				values[0] += (2.0*Math.random()-1.0) * jump*0.01;				values[1] += (2.0*Math.random()-1.0) * jump*0.01;								//色盲平面に落とす。				Dichromat.convertPlane(2, a, b, values);//Bの変化を後付けする。								//境界補正				nextDichroSRGBdash.setValue(values[0], values[1], values[2]);				nextDichroSRGBdash.boundaryRevise(centerAnchor);//SRGB空間で境界補正				nextDichroSRGBdash.getLab(nextDichroLabs[i]);//Labに変換する。			}		}	}		/**	 * 色盲の lms を、色盲平面でランダムにジャンプさせ、 newLms に代入。	 * 境界補正もする。	 * @param lms	 * @param newLMS	 * @param jump	 * @param type 色盲タイプ	 */	void jumpDichromat(LMS lms, LMS newLMS, double jump, int type) {				//LMS空間をランダムジャンプ		lms.getDoubles(values);		for (int i=0;i<3;i++) {			if (i!=type-1) {				values[i] += (2.0*Math.random()-1.0) * jump;				newLMS.setValue(i, values[i]);			}		}				//色盲平面に落として境界補正。		Dichromat.boundaryInConvertNewtonLMS(newLMS, type);	}			/************************************************************	 *						SA の実行							*	 ************************************************************/		/**	 * 指定した温度での安定状態を導く	 * 荒い探索を行い、複数の小エネルギーな色組を保存	 * @param dlmss 元の色であり、最後の色が代入される。	 * @param bestLmss  複数の色組	 * @param bestEnergy 複数のエネルギー候補	 * @param bestSort 配列の順にそのエネルギー順位の番号を指す数が入れられる	 * @param t0	 * @param tStay	 * @param tCold	 * @param tExit	 * @param jump	 * @return	 */	public double simulatedAnnealingTemperture (			LMS[] dlmss, LMS[][] bestLmss, double[] bestEnergy, int[] bestSort,			double t0, int tStay, double tCold, double tExit, double jump) {				plotInit();				// 初期色をランダムにセット		for (int i=0;i<n;i++) {			if (!fixColoring[i]) {				for (int j=0;j<3;j++) preDichroSRGBdash.setValue(j, Math.random());				preDichroSRGBdash.getLMS(dlmss[i]);				Dichromat.boundaryInConvertNewtonLMS(dlmss[i], type);			}		}				// 複数を保存する準備		int bestMax = bestEnergy.length;		for(int i=0;i<bestMax;i++) {			bestSort[i] = i;			bestEnergy[i] = Double.MAX_VALUE;		}				/*		 * 現在の状態の評価		 */		double t = t0;		for(int i=0;i<n;i++)			dlmss[i].getLab(newLabs[i]);		double energy = compDesire.energy(newLabs);				/*		 * 反復処理		 */		double newEnergy;		int loop = 0;		// int count = 0;		// int countMax = 100;		int accept = 0;		int convAccept = 0;		double jumpCold = 0.5;		while(t > tExit) {						// tStay回は温度が一定			for (int tCount=0;tCount<tStay;tCount++) {								// 次状態をセット				for(int i=0;i<n;i++) {					if(!fixColoring[i])						jumpDichromat(dlmss[i], nextDLmss[i], jump, type);					nextDLmss[i].getLab(newDichroLabs[i]);				}				newEnergy = compDesire.energy(newDichroLabs);								// 次状態を評価				double delta = newEnergy - energy;				double et;				if (delta < 0.0 || (!(Double.isInfinite(et=Math.pow(Math.E, -delta/t))) && Math.random() < et)) {					//受理					for(int i=0;i<n;i++) 						dlmss[i].setVector3d(nextDLmss[i]);					energy = newEnergy;					accept++;					// 殿堂入りチェック					if (energy < bestEnergy[bestSort[bestMax-1]]) {						for(int i=0;i<bestMax;i++) {							//該当順位を求める							if (energy < bestEnergy[bestSort[i]]) {								//下位をずらす								int substitute = bestSort[bestMax-1];								for(int j=bestMax-1;j>i;j--) {									bestSort[j] = bestSort[j-1];								}								//該当順位に代入								bestSort[i] = substitute;								for(int k=0;k<n;k++) {									bestLmss[substitute][k].setVector3d(dlmss[k]);								}								bestEnergy[substitute] = energy;								//終了させる								i=bestMax;							}						}					}					plotRun(0, loop, newEnergy);				} else {					//拒否					plotRun(1, loop, newEnergy);				}				loop++;			}			// 冷却処理			t *= tCold;			if (accept < 1) {				if (++convAccept>4) jump = jump*jumpCold;			} else convAccept = 0;			accept = 0;		}				/*		 * 終了処理		 */		for(int i=0;i<n;i++) {			dlmss[i].getLab(nowLabs[i]);			nowDichroLabs[i].setVector3d(nowLabs[i]);		}		plotEnd();		return energy;	}		/**	 * 単純に最小値まで落とすためのSA	 * @param dlmss	 * @param t0	 * @param tStay	 * @param tCold	 * @param jump	 * @param functionEpsilon	 * @return	 */	public double simulatedAnnealingFunctionEpsilon (			LMS[] dlmss, double t0, int tStay, double tCold, double jump, double functionEpsilon) {				plotInit();				double energy;		double newEnergy;		int loop = 0;		int convergence = 0;		int rejectCount = 0;		int rejectPoint = 200;				double t = t0;		for(int i=0;i<n;i++)			dlmss[i].getLab(nowLabs[i]);		energy = compDesire.energy(nowLabs);		System.out.println("epSA start energy="+energy);				search:		while(true) {			// tStay回は温度が一定			for (int tCount=0;tCount<tStay;tCount++) {								// 次状態をセット				for(int i=0;i<n;i++) {					if(!fixColoring[i])						jumpDichromat(dlmss[i], nextDLmss[i], jump, type);					nextDLmss[i].getLab(newDichroLabs[i]);				}				newEnergy = compDesire.energy(newDichroLabs);								// 次状態を評価				double delta = newEnergy - energy;				double et;				boolean energyDown;				if ((energyDown = (delta < 0.0)) || (!(Double.isInfinite(et=Math.pow(Math.E, -delta/t))) && Math.random() < et)) {					//受理					for(int i=0;i<n;i++) 						dlmss[i].setVector3d(nextDLmss[i]);					plotRun(0, loop, newEnergy);					energy = newEnergy;					rejectCount = 0;					if (energyDown && -delta < functionEpsilon) {						if (!(++convergence<3)) break search;					} else convergence = 0;				} else {					//拒否					plotRun(1, loop, newEnergy);					if(!(rejectCount++<rejectPoint)) break search;				}				loop++;			}			// 冷却処理			t *= tCold;		}		/*		 * 終了処理		 */		for(int i=0;i<n;i++) {			dlmss[i].getLab(nowLabs[i]);			nowDichroLabs[i].setVector3d(nowLabs[i]);		}		plotEnd();		System.out.println("epSA end energy="+energy);		return energy;	}		Lab[] solve() {		double t0 = 1000.0;		int tStay = 100;		double tExit = 20;//0.5;		double tCold = 0.95;		double jump = 10.0;		int jumpStay = 2;		double jumpCold = 0.5;		return solve(t0, tStay, tExit, tCold, jump, jumpStay, jumpCold);	}		/**	 * 指定温度間で行うＳＡ	 * @param t0　初期温度	 * @param tStay　一定温度での探索回数	 * @param tExit　終了温度	 * @param tCold　温度の冷却倍率	 * @param jump　初期ジャンプ距離	 * @param jumpStay　ジャンプ冷却をするときのジャンプ失敗回数(×tStay)	 * @param jumpCold　ジャンプの冷却倍率	 * @return Lab[] 配色結果	 */	public Lab[] solve(double t0, int tStay, double tExit, double tCold,			double jump, int jumpStay, double jumpCold) {						//初期色をランダムにセット		for (int i=0;i<newLabs.length;i++) {			if (!fixColoring[i]) {				for (int j=0;j<3;j++) forStartSRGB.setValue(j, Math.random());				forStartSRGB.getLab(nowLabs[i]);			}			nowLabs[i].getLMS(preDichroLMS);			nowDichroLabs[i] = Dichromat.convert(preDichroLMS, type).getLab();			newLabs[i] = nowLabs[i].copyLab();			newDichroLabs[i] = nowDichroLabs[i].copyLab();		}				if (jumpDichroWorld) {			//色盲平面のアンカーベクトルをSRGBdash空間に変換＞a,b　			//TODO 等エネルギー光Eを使っていない。色盲平面としては少し不適。			for (int i=0;i<4;i++) Dichromat.anchor2deg[i].getXYZ().getSRGBdash(anchor[i]);			for (int i=0;i<3;i++) centerAnchor.setValue(i, 0.5);			centerAnchor.getDoubles(c);			if (type==Dichromat.PROTANOPE || type==Dichromat.DEUTERANOPE) {				anchor[0].getDoubles(a);				anchor[1].getDoubles(b);			} else if (type==Dichromat.TRITANOPE) {				anchor[2].getDoubles(a);				anchor[3].getDoubles(b);			} else {				assert false;			}			Dichromat.convertPlane(0, a, b, c);//色の中心cを色盲化して、色盲平面の中心をcに代入		}				double energy = compDesire.energy(nowDichroLabs);		System.out.println("Start Energy :"+energy);		plotInit();				int searchNumber = 0;		int count = 0;		int accept = 0;		int convAccept = 0;		double delta, newEnergy;		do {						//ランダム関数を使って、次の色へジャンプ			if (jumpDichroWorld) jumpDichroPlaneSRGB(nowDichroLabs, newDichroLabs, jump);			else jumpLab(nowLabs, newLabs, newDichroLabs, jump);						//次の色のエネルギー計算			newEnergy = compDesire.energy(newDichroLabs);			delta = newEnergy - energy;			//System.out.println("newEnergy:"+newEnergy);						// 受理できるか判定			double et;			if (delta < 0.0 || (!(Double.isInfinite(et=Math.pow(Math.E, -delta/t0))) && Math.random() < et)) {				//受理				for (int i=0;i<n;i++) {					if (jumpDichroWorld) nowDichroLabs[i].setVector3d(newDichroLabs[i]);					else nowLabs[i].setVector3d(newLabs[i]);									}				energy = newEnergy;				accept++;				plotRun(0, searchNumber, energy);				//System.out.println(jumpNumber+" adopt. : "+newEnergy);			} else {				//拒否				//System.out.print(" N");				plotRun(1, searchNumber, newEnergy);			}			searchNumber++;						//冷却処理			if (!(count<tStay)) {				t0 = t0 * tCold;				count = 0;				if (accept < 1) {					if (!(++convAccept<jumpStay)) jump = jump*jumpCold;				} else convAccept = 0;				accept = 0;			} else count++;/*			if(!(t>epsilon)) {				jump = 0.5;			}*/		} while (t0 > tExit);				// local minimum check		//System.out.println("energy = "+energy);		for (int i=0;i<newLabs.length;i++) {			for (int j=0;j<3;j++) {				if (jumpDichroWorld) nowLabs[i].setValue(j, nowDichroLabs[i].getValue(j));				newLabs[i].setValue(j, nowLabs[i].getValue(j));			}			//System.out.println("color ["+i+"] ="+nowLabs[i]);			//System.out.println("dichro color ["+i+"] ="+dLabs[i]);		}		boolean t1 = true;		for (int i=0;i<newLabs.length;i++) {			for (int j=0;j<3;j++) {				for (int k=0;k<2;k++) {					newLabs[i].setValue(j,nowLabs[i].getValue(j)+(-0.2+0.4*k));					newLabs[i].boundaryReviseSRGBdash();					Dichromat.convert(newLabs[i], newDichroLabs[i], type);					newEnergy = compDesire.energy(newDichroLabs);					t1 = t1 & (energy < newEnergy);				}				newLabs[i].setValue(j, nowLabs[i].getValue(j));			}		}		System.out.println("minimum:"+ t1);				for (int i=0;i<n;i++) {			nowDichroLabs[i] = Dichromat.convert(nowLabs[i], type);		}		System.out.println("EndEnergy:"+compDesire.energy(nowDichroLabs));		plotEnd();		return nowLabs;	}		/**	 * ランダムな初期色からベストいくつかをbestLabs[bestMax][]に書き込む	 * @param bestLabs 答えとなるベスト○○の色の組	 * @param bestEnergy ベスト○○のエネルギー	 * @param bestSort ベスト○○の順位でソートした順序番号	 * @param t0	 * @param tStay	 * @param tExit	 * @param tCold	 * @param jump	 * @param jumpStay	 * @param jumpCold	 */	void solveBest(Lab[][] bestLabs, double[] bestEnergy, int[] bestSort,			double t0, int tStay, double tExit, double tCold,			double jump, int jumpStay, double jumpCold) {						//初期色をランダムにセット		for (int i=0;i<n;i++) {			if (!fixColoring[i]) {				for (int j=0;j<3;j++) forStartSRGB.setValue(j, Math.random());				forStartSRGB.getLab(nowLabs[i]);			}			nowLabs[i].getLMS(preDichroLMS);			nowDichroLabs[i] = Dichromat.convert(preDichroLMS, type).getLab();			newLabs[i] = nowLabs[i].copyLab();			newDichroLabs[i] = nowDichroLabs[i].copyLab();		}				// 複数を保存する準備		int bestMax = bestEnergy.length;		for(int i=0;i<bestMax;i++) {			bestSort[i] = i;			bestEnergy[i] = Double.MAX_VALUE;		}				double energy = compDesire.energy(nowDichroLabs);		System.out.println("Start Energy :"+energy);		plotInit();				int searchNumber = 0;		int count = 0;		int accept = 0;		int convAccept = 0;		double delta, newEnergy, radius = 50.0;		do {						//ランダム関数を使って、次の色へジャンプ			jumpLab(nowLabs, newLabs, newDichroLabs, jump);						//次の色のエネルギー計算			newEnergy = compDesire.energy(newDichroLabs);			delta = newEnergy - energy;						// 受理できるか判定			double et;			if (delta < 0.0 || (!(Double.isInfinite(et=Math.pow(Math.E, -delta/t0))) && Math.random() < et)) {				//受理				for (int i=0;i<n;i++) nowLabs[i].setVector3d(newLabs[i]); 				energy = newEnergy;				accept++;				// 殿堂入りチェック				if (energy < bestEnergy[bestSort[bestMax-1]]) {					for(int i=0;i<bestMax;i++) {						//該当順位を求める						if (energy < bestEnergy[bestSort[i]]) {														//削除した場所を代入ポイントにする。最初は一番下位。							int deleteGrade = bestMax-1;							//下位から似ているものあるかチェック							for(int deletePoint = bestMax-1; deletePoint > i-1; deletePoint--) {								boolean isSimilar = true;								for(int j=0;j<n;j++) {									if (!newDichroLabs[j].match(bestLabs[bestSort[deletePoint]][j], radius)) {										isSimilar = false;										break;									}								}								//似てたらそれを削除し、それの所までの順位がずれる								if (isSimilar) {									deleteGrade = deletePoint;									break;								} else {									//全部似てなければ一番下位を削除。								}							}							int substitute = bestSort[deleteGrade];							//下位をずらす							for(int j=deleteGrade;j>i;j--)								bestSort[j] = bestSort[j-1];							//該当順位に代入							bestSort[i] = substitute;														for(int k=0;k<n;k++) 								bestLabs[substitute][k].setVector3d(newDichroLabs[k]);							bestEnergy[substitute] = energy;							break;						} else {							//上位の色が、今の色と似ているかチェック							boolean isSimilar = true;							for(int j=0;j<n;j++) {								if (!newDichroLabs[j].match(bestLabs[bestSort[i]][j], radius)) {									isSimilar = false;									break;								}							}							//上位に似ているものがあったら、殿堂入りをあきらめる。							if(isSimilar) break;						}					}				}				plotRun(0, searchNumber, energy);			} else {				//拒否				plotRun(1, searchNumber, newEnergy);			}			searchNumber++;						//冷却処理			if (!(count<tStay)) {				t0 = t0 * tCold;				count = 0;				if (accept < 1) {					if (!(++convAccept<jumpStay)) jump = jump*jumpCold;				} else convAccept = 0;				accept = 0;			} else count++;		} while (t0 > tExit);				//終了/*		for (int i=0;i<bestMax;i++) {			System.out.print("sa color["+i+"]= ");			for (int j=0;j<n;j++) {				System.out.println("  "+bestLabs[i][j].toString());			}		}*/		for(int i=0;i<n;i++) Dichromat.convert(nowLabs[i], nowDichroLabs[i], type);		plotEnd();	}		/**	 * 普通の人のためのシミュレーテッドアニーリング	 * @param t0　初期温度	 * @param tStay　一定温度での探索回数	 * @param tExit　終了温度	 * @param tCold　温度の冷却倍率	 * @param jump　初期ジャンプ距離	 * @param jumpStay　ジャンプ冷却をするときのジャンプ失敗回数	 * @param jumpCold　ジャンプの冷却倍率	 * @return	 */	public Lab[] solveTrichromat(double t0, int tStay, double tExit, double tCold,			double jump0, int jumpStay, double jumpCold) {		//初期色をランダムに設定		for (int i=0;i<n;i++) {			if (!fixColoring[i]) {				for (int j=0;j<3;j++) forStartSRGB.setValue(j, Math.random());				forStartSRGB.getLab(nowLabs[i]);			}			newLabs[i] = nowLabs[i].copyLab();		}		double energy = compDesire.energy(nowLabs);		System.out.println("Start Energy :"+energy);		plotInit();				double t = t0;		double jump = jump0;		int searchNumber = 0;		int count = 0;		int accept = 0;		int convAccept = 0;		double delta, newEnergy;		do {						//ランダム関数を使って、次の色へジャンプ			for (int i=0;i<n;i++)				if (!fixColoring[i]) jump(nowLabs[i], newLabs[i], jump);						//次の色のエネルギー計算			newEnergy = compDesire.energy(newLabs);			delta = newEnergy - energy;			//System.out.println("newEnergy:"+newEnergy);						// 受理できるか判定			double et;			if (delta < 0.0 || (!(Double.isInfinite(et=Math.pow(Math.E, -delta/t))) && Math.random() < et)) {				//受理				for (int i=0;i<n;i++) nowLabs[i].setVector3d(newLabs[i]);				energy = newEnergy;				accept++;				plotRun(0, searchNumber, energy);				//System.out.println(jumpNumber+" adopt. : "+newEnergy);			} else {				//拒否				//System.out.print(" N");				plotRun(1, searchNumber, newEnergy);			}			searchNumber++;						//冷却処理			if (!(count<tStay)) {				t = t * tCold;				count = 0;				if (accept < 1) {					if (!(++convAccept<jumpStay)) jump = jump*jumpCold;				} else convAccept = 0;				accept = 0;			} else count++;		} while (t > tExit);		System.out.println("EndEnergy:"+compDesire.energy(nowLabs));		for(int i=0;i<n;i++) nowDichroLabs[i].setVector3d(nowLabs[i]);		plotEnd();		return nowLabs;	}		//総合エネルギー	double energy() {		return compDesire.energy(nowDichroLabs);	}	//識別性エネルギー	double distinguishabilityEnergy() {		return compDesire.baseOfDistinguish(nowDichroLabs);	}	//部分的識別性エネルギー	double distinguishabilityEnergy(int i, int j) {		return compDesire.baseOfDistinguish(nowDichroLabs, i, j);	}	//コントラストエネルギー	double contrastEnergy() {		return compDesire.baseOfContrast(nowDichroLabs);	}	//部分的コントラストエネルギー	double contrastEnergy(int i, int j) {		return compDesire.baseOfContrast(nowDichroLabs, i, j);	}	//保存性エネルギー	double keepabilityEnergy() {		return compDesire.baseOfKeep(nowDichroLabs);	}	//部分的保存性エネルギー	double keepabilityEnergy(int i) {		return compDesire.baseOfKeep(nowDichroLabs, i);	}		/**	 * GnuPlot用　エネルギーの減少過程データの出力、初期化部	 */	private void plotInit () {		if (!plotting) return;		// Date date = new Date();		// DateFormat df = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss-SS");		fw = new FileWriter[2];		bw = new BufferedWriter[2];		File[] file = new File[2];/*		file[0] = new File(".\\"+df.format(date)+"ACC.txt");		file[1] = new File(".\\"+df.format(date)+"REJ.txt");*/		file[0] = new File(".\\SAandNewtonACC"+plotNum+".txt");		file[1] = new File(".\\SAandNewtonREJ"+plotNum+".txt");		plotNum++;		for (int i=0;i<2;i++) {			if (file[i].exists()) {				file[i].delete();				System.out.print(file[i].getName()+" has already existed. ");				System.out.println("This file was deleted.");			}		}		try {			for (int i=0;i<2;i++) {				fw[i] = new FileWriter(file[i]);				bw[i] = new BufferedWriter(fw[i]);				bw[i].write("# ColorNum = "+n+"\n");				bw[i].write("# "+Dichromat.typeString(type)+"\n");				boolean fixNaturalColoring = false;				for (int j=0;j<n;j++) fixNaturalColoring |= fixColoring[j];				bw[i].write("# fixColoring = "+fixNaturalColoring+"\n");			}		} catch (Exception e) {			System.out.println("Exception in SimulatedAnnealing plotInit : "+e);		}	}	/**	 * GnuPlot用　エネルギーの減少過程データの出力、主要部	 * @param logNum  0:ACCept log, 1:REJect log	 * @param searchNum Simulated Annealing　で探索した回数	 * @param energy 現在のエネルギーの値	 */	private void plotRun (int logNum, int searchNum, double energy) {		if (!plotting) return;		try {			bw[logNum].write(searchNum+" "+energy+"\n");		} catch (Exception e) {			System.out.println("Exception in SimulatedAnnealing plotRun : "+e);		}	}	/**	 * GnuPlot用　エネルギーの減少過程データの出力、終了処理部	 */	private void plotEnd () {		if (!plotting) return;		try {			for (int i=0;i<2;i++) {				bw[i].close();				fw[i].close();			}		} catch (Exception e) {			System.out.println("Exception in SimulatedAnnealing plotEnd : "+e);		}	}}