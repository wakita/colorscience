/* * 作成日： 2004/10/28 */package jp.ac.titech.is.wakitalab.color.shimamura;/** * @author shinamu1 */public class NNMatrix {		static void plus(double[][] m1, double num) {		for(int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) m1[i][j] += num;		}	}	static void mius(double[][] m1, double num) {		for(int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) m1[i][j] -= num;		}	}	static void multi(double[][] m1, double num) {		for(int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) m1[i][j] *= num;		}	}	static void devide(double[][] m1, double num) {		for(int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) m1[i][j] /= num;		}	}		static double[][] MplusM(double[][] m1, double[][] m2) {		double[][] answer = new double[m1.length][m1.length];		MplusM(m1, m2, answer);		return answer;	}	static void MplusM(double[][] m1, double[][] m2, double[][] answer) {		assert m1.length == m2.length && m1.length == answer.length;		for (int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) answer[i][j] = m1[i][j] + m2[i][j];		}	}		static double[][] MminusM(double[][] m1, double[][] m2) {		double[][] answer = new double[m1.length][m1.length];		MminusM(m1, m2, answer);		return answer;	}	static void MminusM(double[][] m1, double[][] m2, double[][] answer) {		assert m1.length == m2.length && m1.length == answer.length;		for (int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) answer[i][j] = m1[i][j] - m2[i][j];		}	}		static double[][] MmultiM(double[][] m1, double[][] m2) {		double[][] answer = new double[m1.length][m1.length];		MmultiM(m1, m2, answer);		return answer;	}	static void MmultiM(double[][] m1, double[][] m2, double[][] answer) {		assert m1.length == m2.length && m1.length == answer.length;		double tmp = 0.0;		for (int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) {				for (int k=0;k<m1.length;k++) {					tmp += m1[i][k] * m2[k][j];				}				answer[i][j] = tmp;				tmp = 0.0;			}		}	}		static double[] MmultiV(double[][] m1, double[] v1) {		double[] answer = new double[m1.length];		MmultiV(m1, v1, answer);		return answer;	}	static void MmultiV(double[][] m1, double[] v1, double[] answer) {		assert m1.length == v1.length && m1.length == answer.length;		double tmp = 0.0;		for (int i=0;i<m1.length;i++) {			for (int j=0;j<m1.length;j++) tmp += m1[i][j] * v1[j];			answer[i] = tmp;			tmp = 0.0;		}	}	/**	 * calculate inverse-matrix from n*n base-matrix	 * @param base : base-matrix	 * @param inv : inverse-matrix is to inserted	 */	static void inverse (double[][] base, double[][] inv) {		int n = base.length;		assert base.length == inv.length && base.length == base[0].length && inv.length == inv[0].length;		final double[][] tmp = new double[n][n];		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) tmp[i][j] = base[i][j];		}		for(int i = 0; i < n; i++ ){	        for(int j = i+1; j < n; j++ ){	        	if(tmp[i][i] < 1.0E-30) {	        		if (tmp[i][i] > -1.0E-30) {		        		if (tmp[i][i] > 0) tmp[i][i] = 1.0E-30;		        		else tmp[i][i] = -1.0E-30;	        		}	        	}	            tmp[j][i] /= tmp[i][i];	            for(int k = i+1; k < n; k++ ){	                tmp[j][k] -= tmp[i][k] * tmp[j][i];	            }	        }	    }	    /* inverse process */	    for(int k = 0; k < n; k++ ){	        /* initialize */	        for(int i = 0; i < n; i++ ){	            if( i == k ){ inv[i][k] = 1; }	            else{ inv[i][k] = 0; }	        }	        /* calculate inverse */	        for(int i = 0; i < n; i++ ){	            for(int j = i+1; j < n; j++ ){	                inv[j][k] -= inv[i][k] * tmp[j][i];	            }	        }	        for(int i = n-1; i >= 0; i-- ){	            for(int j = i+1; j<n; j++ ){	                inv[i][k] -= tmp[i][j] * inv[j][k];	            }	        	if(tmp[i][k] < 1.0E-30) {	        		if (tmp[i][k] > -1.0E-30) {		        		if (tmp[i][k] > 0) tmp[i][k] = 1.0E-30;		        		else tmp[i][k] = -1.0E-30;	        		}	        	}	            inv[i][k] /= tmp[i][i];	        }	    }	}		static void houseHolder (double[][] m, double[][] ans) {		assert m.length == ans.length;		int n = m.length;		double b[] = new double[n];		double newB[] = new double[n];		double v[] = new double[n];		// double q[][] = new double[n][n];		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) ans[i][j] = m[i][j];		}		for (int i=0;i<n;i++) newB[i] = 0.0;				for (int k=0;k<n-2;k++) {			double ss = 0.0;			for (int i=k+1;i<n;i++) {				b[i] = ans[i][k];				ss += b[i] * b[i];			}			double s = Math.sqrt(ss);			newB[k+1] = s;			for (int i=k+1;i<n;i++) v[i] = b[i] - newB[i];			double nolm = 0.0;			for (int i=k+1;i<n;i++) nolm += v[i] * v[i];			nolm = Math.sqrt(nolm);			// make Q and...		}	}}