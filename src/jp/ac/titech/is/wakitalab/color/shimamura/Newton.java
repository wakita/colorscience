/* * 作成日： 2004/12/24 */package jp.ac.titech.is.wakitalab.color.shimamura;/** * @author shinamu1 */public class Newton {//TODO fixColoringを入れる。		/**	 * 願望関数（理想状態と願望の重みから成る）	 */	private CompoundDesire compoundDesire;	int type;	/**	 * エネルギーの管理テーブル	 */	double[] energyLineTable, keepEnergyTable, penaltyTable;	double[][] contEnergyTable, distEnergyTable;	/**	 * 願望中の色数	 */	// private int n;	/**	 * ニュートン法実行時のエネルギー情報	 */	private double vEnergyNow;	/**	 * ニュートン法実行時に使われるオブジェクト	 */	double[] grad = new double[2], down = new double[2];	double[][] hesse = new double[2][2], hesseInverseMinus = new double[2][2];	LMS dlmsNow = new LMS(), dlmsNext = new LMS();	/**	 * 願望関数やエネルギーのキャッシュテーブルは、外部で初期化してコンストラクターに与えられる。	 * @param compoundDesire	 * @param contEnergyTable	 * @param distEnergyTable	 * @param keepEnergyTable	 * @param penaltyTable	 * @param energyLineTable	 * @param type	 */	Newton (CompoundDesire compoundDesire, double[][] contEnergyTable, double[][] distEnergyTable,			double[] keepEnergyTable, double[] penaltyTable, double[] energyLineTable, int type) {				this.compoundDesire = compoundDesire;		// n = compoundDesire.dimension();		this.type = type;		this.contEnergyTable = contEnergyTable;		this.distEnergyTable = distEnergyTable;		this.keepEnergyTable = keepEnergyTable;		this.penaltyTable = penaltyTable;		this.energyLineTable = energyLineTable;	}		/**	 * 意味：降下方向を導出し直線探索を一回行う。	 * 入力：結果は、compoundDesire, type, dlmss, v に因る。	 * 出力：v に関するエネルギーが返され、v に関するエネルギーテーブルが正しくキャッシュされる。	 * @param dlmss 現在の色盲の色の配列	 * @param v 変更させる色の番	 * @return	 */	private double step (LMS[] dlmss, int v) {		double alpha = 0.1;//Armijo での初期（最大）ステップ幅 TODO 適切な値を調査		double span;		double determinantEpsilon = 1.0E-5, gamma = 0.8, xi = 0.2, funEpsilon = 1.0E-3;		double vEnergyNext, vEnergyExpect;		double u;//方向微分値				//現在の色に関する、願望のエネルギーと微分、二次微分を計算する		vEnergyNow = compoundDesire.energyGradHesse(dlmss, v, grad, hesse, type);		//System.out.println("vEnergyNow="+vEnergyNow);/*		System.out.println("fx        ="+compoundDesire.energyNewton(v, dlmss,				contEnergyTable, distEnergyTable, keepEnergyTable, penaltyTable, type));		System.out.println("grad = ("+grad[0]+", "+grad[1]+")");		System.out.println("hesse = ("+hesse[0][0]+", "+hesse[0][1]+")");		System.out.println("        ("+hesse[1][0]+", "+hesse[1][1]+")");*/				//行列式が正となるように単位行列を加算		double ad = hesse[0][0]*hesse[1][1];		double bc = hesse[0][1]*hesse[1][0];		double det = ad - bc;//hesse[0][0]*hesse[1][1]-hesse[0][1]*hesse[1][0];		while(Math.abs(det)<determinantEpsilon) {			System.out.println("determinant = 0");			hesse[0][0]*=1.00001;			hesse[1][1]*=1.00001;			ad = hesse[0][0]*hesse[1][1];			bc = hesse[0][1]*hesse[1][0];			det = ad - bc;//hesse[0][0]*hesse[1][1]-hesse[0][1]*hesse[1][0];		}				//固有値の計算		double eigenValue0, eigenValue1 = 0,  unitMatrixPlus=0,		h00Ph11=0, h00Mh11=0, h01Xh10=0, h00Xh11=0, h00Ph11sq = 0, eigenD=0,		hesse00 = hesse[0][0], hesse01 = hesse[0][1],		hesse10 = hesse[1][0], hesse11 = hesse[1][1];		h00Ph11 = hesse00 + hesse11;		h00Mh11 = hesse00 - hesse11;		h01Xh10 = hesse01 * hesse10;		eigenD= Math.sqrt( h00Mh11 * h00Mh11 + 4 * h01Xh10 );		eigenValue0 = (h00Ph11 - eigenD) / 2.0;		eigenValue1 = (h00Ph11 + eigenD) / 2.0;		//固有値が正でなければ単位行列を unitMatrixPlus 分だけ足す。		if(!(eigenValue0 > 0 && eigenValue1 > 0)){			//System.out.println("negative eigenValues. eigenValue0="+eigenValue0+", eigenValue1="+eigenValue1);			h00Xh11= hesse00*hesse11;			h00Ph11sq= h00Ph11*h00Ph11;			if (4*(h00Xh11-h01Xh10) - h00Ph11sq > 0) {				unitMatrixPlus = -h00Ph11 / 2.0 + 1.0;			} else {				unitMatrixPlus = (-h00Ph11 - Math.sqrt (h00Ph11sq - 4* (h00Xh11 - h01Xh10)) )/2.0 + 1.0;				if(unitMatrixPlus < 0 || unitMatrixPlus < -hesse00 || unitMatrixPlus < -hesse11) {					unitMatrixPlus = (-h00Ph11 + Math.sqrt (h00Ph11sq - 4* (h00Xh11 - h01Xh10)) )/2.0;					unitMatrixPlus = Math.max(unitMatrixPlus, Math.max(-hesse00, -hesse11)) + 1.0;				}			}			hesse00 += unitMatrixPlus;			hesse11 += unitMatrixPlus;		} else {//			System.out.println("positive eigenValues. n="+n);		}		// double h00Ph11_ = hesse00 + hesse11;		// double h00Mh11_ = hesse00 - hesse11;		//h01Xh10 = hesse01 * hesse10;		// double eigenD_ = Math.sqrt( h00Mh11_ * h00Mh11_ + 4 * h01Xh10 );		// double eigenValue0_ = (h00Ph11_ - eigenD_) / 2.0;		// double eigenValue1_ = (h00Ph11_ + eigenD_) / 2.0;		/*		System.out.println("hesse' = ("+hesse00+", "+hesse01+")");		System.out.println("         ("+hesse10+", "+hesse11+")");*/				//逆行列のマイナス		hesseInverseMinus[0][0] = -hesse11;		hesseInverseMinus[1][1] = -hesse00;		hesseInverseMinus[0][1] = hesse01;		hesseInverseMinus[1][0] = hesse10;		//降下方向ベクトル down の計算		NNMatrix.MmultiV(hesseInverseMinus, grad, down);		//降下方向ベクトル down の正規化		double downLength = Math.sqrt(down[0]*down[0] + down[1]*down[1]);		down[0] /= downLength;		down[1] /= downLength;//		System.out.print("down[0]="+(int)(down[0]*10000)+", dowon[1]="+(int)(down[1]*10000));		u = grad[0]*down[0] + grad[1]*down[1];//		System.out.println(",     u="+u);		if (u>0) {			System.out.println("down direction fault.( u = "+u+" )");			return -1;		}				//Armijo 初期点 dlmsNow から span だけ進んだ点を探索。		dlmsNow.setVector3d((Vector3D)dlmss[v]);		span = alpha;		boolean nextIsLong;				while(true) {						//直線探索の次の色を決定			int k=0;			for(int i=0;i<3;i++) {				if(i!=type-1) {					dlmsNext.setValue(i, dlmsNow.getValue(i) + span * down[k++]);				}// M_(k+1) = M_k + alpha * d_k[0],   S_(k+1) = S_k + alpha * d_k[1]			}			//次の色の色盲変換平面の選択			nextIsLong = Dichromat.choiceAnchor(dlmsNext, type);			//この色盲平面での境界条件チェック			if(CompoundDesire.boundaryCheck(dlmsNext, nextIsLong, type)) {								//次の点に欲しいエネルギーの最大許容値				vEnergyExpect = vEnergyNow + xi*u*span;				//次の点のエネルギー計算				Dichromat.convertPlane(dlmsNext, dlmss[v], nextIsLong, type);				vEnergyNext = compoundDesire.energyNewton					(v, dlmss, contEnergyTable, distEnergyTable, keepEnergyTable, penaltyTable, type);				//許容範囲なら直線探索を終了する。				if (vEnergyExpect - vEnergyNext > -funEpsilon) break;			}			//探索中の次の点が境界外、または一定水準未満のエネルギーであった場合はループ			span *= gamma;		}		/*		if (span>0.05) System.out.print("**");		System.out.print("span ="+span+",  dlmss["+v+"]="+dlmss[v]);*/		return vEnergyNext;	}	/**	 * 意味：色 v に対してニュートン法で収束点を求める。	 * 入力：@param とcompoundDesire, type に因る。	 * 出力：収束点を返し、v に関するエネルギーテーブルのみ更新される。	 * @param dlmss	 * @param v	 * @param fx_now	 * @param ep	 * @return	 */	public double newton (LMS[] dlmss, int v, double ep) {		double fx_next = 0;		int loop = 0;/*		System.out.println("\n v="+v);		System.out.println("   before SRGB="+dlmss[v].getSRGB()+",  LMS="+dlmss[v]);*/		while(true) {/*			System.out.println("\n    newton loop="+(loop));*/			loop++;			// 一回、傾きを求めて直線探索。			fx_next = step(dlmss, v);/*			System.out.println("   SRGB="+dlmss[v].getSRGB()+",  LMS="+dlmss[v]);			System.out.println("fx_next="+fx_next);*/			// 収束したら終了			if(vEnergyNow - fx_next < ep) break;		}/*		System.out.println("   loop = "+loop);		System.out.println("   after SRGB="+dlmss[v].getSRGB());*/		// 収束点を返す		return fx_next;	}	}