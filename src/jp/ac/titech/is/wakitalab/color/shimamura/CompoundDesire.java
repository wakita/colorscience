/* * 作成日: 2004/07/02 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** *  * @author shinamu1 */public class CompoundDesire implements Desire, Serializable {		int dimension = -1;		private DesiredDistinguishability desiredDistinguishability;	private DesiredContrast desiredContrast;	private DesiredKeepability desiredKeepability;		static final long serialVersionUID = "CompoundDesire".hashCode();		/**	 * ペナルティ関数のLog -log(al+bm+cs+d)	 * の内側の係数値 : PRO b,c,d, DEU a,c,d, TRI a,b,d	 * [PRO,DEU,TRI][R,G,B,1-R,1-G,1-B][{b,c,d}or{a,c,d}or{a,b,d}]	 */	private static double[][][] PenaltyRGBLMSLong =	{{	{6.824539859891896, - 2.5120192769055256, 0},		{4.115806148900741, - 0.7918875194433959, 0},		{-0.567404851173817, + 6.491104494295181, 0},		{-6.824539859891896, 2.5120192769055256, 1},		{-4.115806148900741, 0.7918875194433959, 1},		{0.567404851173817, -6.491104494295181, 1}},	{	{5.09112647548636, - 1.5423809142486817, 0},		{3.0704032920645963, - 0.2071091142812487, 0},		{-0.4232856601963166, + 6.410486969575435, 0},		{-5.09112647548636, 1.5423809142486817, 1},		{-3.0704032920645963, 0.2071091142812487, 1},		{0.4232856601963166, -6.410486969575435, 1}},	{	{19.9088337898773, - 19.074283865385915, 0},		{-2.7264605070353776, + 6.962693112419638, 0},		{-0.4003580236067533, + 3.921780916142105, 0},		{-19.9088337898773, 19.074283865385915, 1},		{2.7264605070353776, -6.962693112419638, 1},		{0.4003580236067533, -3.921780916142105, 1}}};	private static double[][][] PenaltyRGBLMSShort =	{{	{8.66083365242939, - 5.492287871069451, 0},		{3.8586856935474665, - 0.3745860935383388, 0},		{-0.572324490551587, + 6.49908897193801, 0},		{-8.66083365242939, 5.492287871069451, 1},		{-3.8586856935474665, 0.3745860935383388, 1},		{0.572324490551587, - 6.49908897193801, 1}},	{	{6.046408591790769, - 3.4387227036638137, 0},		{2.6938735076548954, + 0.5403445990760862, 0},		{-0.39955827069749883, + 6.363385448995938, 0},		{-6.046408591790769, 3.4387227036638137, 1},		{-2.6938735076548954, - 0.5403445990760862, 1},		{0.39955827069749883, - 6.363385448995938, 1}},	{	{18.99088107738458, - 17.951510665850453, 0},		{-1.785976711792278, + 5.8123615261346595, 0},		{-5.001678229821525, + 9.549782162513381, 0},		{-18.99088107738458, 17.951510665850453, 1},		{1.785976711792278, - 5.8123615261346595, 1},		{5.001678229821525, - 9.549782162513381, 1}}};		private static double[] xyzPDT1=new double[3], xyzPDT2=new double[3],						  	xyz1_13=new double[3], xyz2_13=new double[3],							xyz_23=new double[3], xyz_53=new double[3],							labPDT=new double[3], hDelta=new double[2],							fy=new double[2], fFy=new double[4];	private static double[] aMbSc = new double[6], penaltyBase = new double[6];	private static double[][] abc = new double[6][3], penaltyGrad = new double[6][2];	private static double[][][] penaltyHesse = new double[6][2][2];	double[] gradBase = new double[2], gradSq = new double[2];	double[][] hesseBase = new double[2][2], hesseSq = new double[2][2];	double[] desiredBase = new double[4];	double[][] desiredGrad = new double[4][2];	double[][][] desiredHesse = new double[4][2][2];	private static double[] ms1 = new double[3];	private static double[] delta345 = new double[3];	private final static double smallNum = 1.0E-15;	/**	 * @param n : total color-number	 */	public CompoundDesire(int n) {		dimension = n;	}		/**	 * 願望の加算	 * @param desire	 */	public void add(SimpleDesire desire) {		if (desire == null) return;				assert dimension == -1 || dimension == desire.dimension() :			"dimension="+dimension+", but added dimension="+desire.dimension();				if (desire instanceof DesiredDistinguishability) {			DesiredDistinguishability dd = (DesiredDistinguishability)desire;			if (desiredDistinguishability == null)				desiredDistinguishability = dd;			else				desiredDistinguishability.plus(dd);		} else if (desire instanceof DesiredContrast) {			DesiredContrast dc = (DesiredContrast)desire;			if (desiredContrast == null)				desiredContrast = dc;			else				desiredContrast.plus(dc);		} else if (desire instanceof DesiredKeepability) {			DesiredKeepability dk = (DesiredKeepability)desire;			if (desiredKeepability == null)				desiredKeepability = dk;			else				desiredKeepability.plus(dk);		}	}	private void add(CompoundDesire desire) {		add(desire.desiredDistinguishability);		add(desire.desiredContrast);		add(desire.desiredKeepability);	}	void add(Desire desire) {		assert desire instanceof SimpleDesire || desire instanceof CompoundDesire;		if (desire instanceof SimpleDesire)			add((SimpleDesire)desire);		else if			(desire instanceof CompoundDesire) add((CompoundDesire)desire);	}	void add(Desire[] desires) {		for (int i=0;i<desires.length;i++) add(desires[i]);	}		/**	 * 次元	 * @return 色数	 */	public int dimension() { return dimension; }		/**	 * 理想のコントラスト	 * @param i 色番号	 * @param j 色番号	 * @return 理想値	 */	double getContrastIdeal(int i, int j) {		if (desiredContrast != null) return desiredContrast.getIdeal(i,j);		else return 0.0;	}	/**	 * 理想値をコピーして渡す	 * @return	 */	double[][] getContIdeal() {		if (desiredContrast!=null) return desiredContrast.getIdeal();		else return null;	}	Lab[] getKeepIdealLab() {		if (desiredKeepability!=null) return desiredKeepability.getIdealLab();		else return null;	}	LMS[] getKeepIdealLMS() {		if (desiredKeepability!=null) return desiredKeepability.getIdealLMS();		else return null;	}		/**	 * 願望の重要度配列をコピーして渡す	 * @return	 */	double[][] getContGravity() {		if(desiredContrast!=null) return desiredContrast.getGravity();		else return null;	}	double[][] getDistGravity() {		if(desiredDistinguishability != null) return desiredDistinguishability.getGravity();		else return null;	}	double[] getKeepGravity() {		if(desiredKeepability != null) return desiredKeepability.getGravity();		else return null;	}		/**	 * 複製用メソッド	 * @return	 */	CompoundDesire copy() {		CompoundDesire newCompoundDesire = new CompoundDesire(dimension);		if (desiredDistinguishability!=null){			DesiredDistinguishability newDDesire = new DesiredDistinguishability(desiredDistinguishability.gravity, desiredDistinguishability.type);			newCompoundDesire.add(newDDesire);		}		if (desiredContrast!=null){			DesiredContrast newCDesire = new DesiredContrast(desiredContrast.ideal, desiredContrast.gravity, desiredContrast.type);			newCompoundDesire.add(newCDesire);		}		if (desiredKeepability!=null){			DesiredKeepability newKDesire = new DesiredKeepability(desiredKeepability.idealLabs, desiredKeepability.gravity, desiredKeepability.type);			newCompoundDesire.add(newKDesire);		}		return newCompoundDesire;	}		/************************************************************	 *****              Lab でのエネルギー計算          *********	 ************************************************************/				/**	 * 基本関数	 * @param labs　色のLab配列	 * @param i　色１のindex	 * @param j 色２のindex	 * @return	 */	public double energy(Lab[] labs, int i, int j) {		double result = 0.0;		if (desiredDistinguishability != null) result += desiredDistinguishability.energy(labs,i,j);		if (desiredContrast != null) result += desiredContrast.energy(labs,i,j);		if (desiredKeepability != null) result += desiredKeepability.energy(labs,i);		return result;	}	public double energy(Lab[] labs, int i) {		double result = 0.0;		if (desiredDistinguishability != null) {			for (int j=0;j<dimension;j++) result += desiredDistinguishability.energy(labs,i,j);		}		if (desiredContrast != null) {			for (int j=0;j<dimension;j++) result += desiredContrast.energy(labs,i,j);		}		if (desiredKeepability != null) result += desiredKeepability.energy(labs,i);		return result;	}	public double energy(Lab[] labs) {		double result = 0.0;		if (desiredDistinguishability != null) result += desiredDistinguishability.energy(labs);		if (desiredContrast != null) result += desiredContrast.energy(labs);		if (desiredKeepability != null) result += desiredKeepability.energy(labs);		return result;	}	public double energy(Lab[] labs, double[][] contEnergyTable, double[][] distEnergyTable, double[] keepEnergyTable) {		double energy = 0.0;		if (desiredDistinguishability != null)			energy += desiredDistinguishability.energy(labs, distEnergyTable);		if (desiredContrast != null) 			energy += desiredContrast.energy(labs, distEnergyTable);		if (desiredKeepability != null)			energy += desiredKeepability.energy(labs, keepEnergyTable);		return energy;	}	/**	 * 願望ごとの基本関数呼び出し	 * @param labs	 * @param i	 * @param j	 * @return base	 */	public double baseOfDistinguish(Lab[] labs, int i, int j) {		if (desiredDistinguishability != null) return desiredDistinguishability.energy(labs,i,j);		else return 0;	}	public double baseOfContrast(Lab[] labs, int i, int j) {		if (desiredContrast != null) return desiredContrast.energy(labs,i,j);		else return 0.0;	}	public double baseOfKeep(Lab[] labs, int i) {		if (desiredKeepability != null) return desiredKeepability.energy(labs,i);		else return 0.0;	}		/**	 * 願望ごとの基本関数呼び出し。すべての色について。	 * @param labs	 */	public double baseOfDistinguish(Lab[] labs) {		if (desiredDistinguishability != null) return desiredDistinguishability.energy(labs);		else return 0.0;	}	public double baseOfContrast(Lab[] labs) {		if (desiredContrast != null) return desiredContrast.energy(labs);		else return 0.0;	}	public double baseOfKeep(Lab[] labs) {		if (desiredKeepability != null) return desiredKeepability.energy(labs);		else return 0.0;	}					/************************************************************	 * ニュートン法で色盲LMS配列を用いた擬似エネルギーの計算	*	 ************************************************************/				/*	 * 基本関数 : このクラスのそれぞれの願望についての基本関数を呼び出す。	 * 計算コストが高い。Mathematicaの手法による計算。	 */	public double energyNewton(LMS[] dlmss, int i, int j) {		double result = 0.0;		result += distEnergyNewton(dlmss,i,j);		result += contEnergyNewton(dlmss,i,j);		return result;	}	public double energyNewton(LMS[] dlmss, int i) {		double result = 0.0;		for (int j=0;j<dimension;j++)			result += distEnergyNewton(dlmss,i,j);		for (int j=0;j<dimension;j++)			result += contEnergyNewton(dlmss,i,j);		result = keepEnergyNewton(dlmss,i);		return result;	}	public double energyNewton(LMS[] dlmss) {		double result = 0.0;		result += distEnergyNewton(dlmss);		result += contEnergyNewton(dlmss);		result += keepEnergyNewton(dlmss);		return result;	}	/*	 * 識別性  の基本関数 : 識別性の願望オブジェクトの基本関数を呼び出す。	 */	public double distEnergyNewton(LMS[] dlmss, int i, int j) {		if (desiredDistinguishability != null)			return desiredDistinguishability.energyNewton(dlmss, i, j);		else return 0.0;	}	public double distEnergyNewton(LMS[] dlmss, int i) {		double result = 0.0;		if (desiredDistinguishability != null) {			for (int j=0;j<dimension;j++)				result += desiredDistinguishability.energyNewton(dlmss, i, j);		}		return result;	}	public double distEnergyNewton(LMS[] dlmss) {		if (desiredDistinguishability != null) return desiredDistinguishability.energyNewton(dlmss);		else return 0.0;	}	/*	 * コントラスト  の基本関数 : コントラストの願望オブジェクトの基本関数を呼び出す。	 */	public double contEnergyNewton(LMS[] dlmss, int i, int j) {		if (desiredContrast != null) return desiredContrast.energyNewton(dlmss,i,j);		else return 0.0;	}	public double contEnergyNewton(LMS[] dlmss, int i) {		double result = 0.0;		if (desiredContrast != null) {			for (int j=0;j<dimension;j++)				result += contEnergyNewton(dlmss,i,j);		}		return result;	}	public double contEnergyNewton(LMS[] dlmss) {		if (desiredContrast != null) return desiredContrast.energyNewton(dlmss);		else return 0.0;	}	/*	 * 色の自然性　の基本関数 : 色の自然性の願望オブジェクトの基本関数を呼び出す。	 */	public double keepEnergyNewton(LMS[] dlmss, int i) {		if (desiredKeepability != null) return desiredKeepability.energyNewton(dlmss,i);		else return 0.0;	}	public double keepEnergyNewton(LMS[] dlmss) {		if (desiredKeepability != null) return desiredKeepability.energyNewton(dlmss);		else return 0.0;	}		/**	 * 単純にペナルティを計算する	 * @param lms 正常者の色でも、色盲の色でもOK	 * @param type	 * @return	 */	public static double getPenalty(LMS lms, int type) {		double penalty = 0.0;		boolean isLong = Dichromat.choiceAnchor(lms, type);		double[][][] penaltyRGBLMS = isLong ? PenaltyRGBLMSLong : PenaltyRGBLMSShort;		int val=0;		for (int i=0;i<3;i++) {			if (i!=type-1) {				ms1[val] = lms.getValue(i);				val++;			}		}		ms1[2] = 1;		for (int i=0;i<6;i++) {			aMbSc[i] = 0.0;			for (int j=0;j<3;j++) {				abc[i][j] = penaltyRGBLMS[type-1][i][j];				aMbSc[i] += abc[i][j]*ms1[j];			}			if(aMbSc[i]<smallNum) aMbSc[i]=smallNum;			penalty += penaltyBase[i] = -Math.log(aMbSc[i]);		}		return penalty;	}				/************************************************************	 *****      エネルギーを求めてテーブルに保存する       ******	 ************************************************************/		/**	 * 色 dlmss[v] 関するエネルギーのみを計算。	 * 各願望の gravity を覗き見て必要のない願望は計算しない。	 * ニュートン法の内部で呼ぶので極力無駄をしない。	 * @param dlmss	 * @param v	 * @param type	 * @return	 */	public double energyNewton(int v, LMS[] dlmss, double[][] contEnergyTable,			double[][] distEnergyTable, double[] keepEnergyTable, double[] penaltyTable,			int type) {		double delta = 0, energy = 0;		boolean contExist = desiredContrast != null,				distExist = desiredDistinguishability != null,				keepExist = desiredKeepability != null,				conDo, disDo;		for(int i=0;i<3;i++) desiredBase[i] = 0.0;		//色 v に関わる願望計算		for(int j=0;j<dimension;j++) {			if((conDo = (contExist && desiredContrast.gravity[v][j]>0)) |				(disDo = (distExist && desiredDistinguishability.gravity[v][j]>0))) {				delta = deltaDICHROLMS(dlmss[v], dlmss[j], type);				if(conDo)					contEnergyTable[v][j] = contEnergyTable[j][v] =						desiredContrast.energyNewtonWithDelta(v,j,delta);				else contEnergyTable[v][j] = contEnergyTable[j][v] = 0;				if(disDo)					distEnergyTable[v][j] = distEnergyTable[j][v] =						desiredDistinguishability.energyNewtonWithDelta(v,j,delta);				else distEnergyTable[v][j] = distEnergyTable[j][v] = 0;				energy += contEnergyTable[v][j]+distEnergyTable[v][j];			} else {				contEnergyTable[v][j] = contEnergyTable[j][v] = 0;				distEnergyTable[v][j] = distEnergyTable[j][v] = 0;			}		}		if(keepExist && desiredKeepability.gravity[v]>0) {			keepEnergyTable[v] = desiredKeepability.energyNewton(v, dlmss[v]);			energy += keepEnergyTable[v];		} else keepEnergyTable[v] = 0;		penaltyTable[v] = getPenalty(dlmss[v], type, desiredGrad[3], desiredHesse[3]);		energy += penaltyTable[v];		return energy;	}	/**	 * 全体のニュートンエネルギーを求めて、テーブルに保存	 * @param dlmss	 * @param contEnergyTable	 * @param distEnergyTable	 * @param keepEnergyTable	 * @param penaltyTable	 * @param type	 * @return	 */	public double energyNewton(LMS[] dlmss, double[][] contEnergyTable, double[][] distEnergyTable,			double[] keepEnergyTable, double[] penaltyTable, int type) {		double energy = 0.0;		if (desiredContrast != null)			energy += desiredContrast.energyNewton(dlmss, contEnergyTable);		if (desiredDistinguishability != null)			energy += desiredDistinguishability.energyNewton(dlmss, distEnergyTable);		if(desiredKeepability != null)			energy += desiredKeepability.energyNewton(dlmss, keepEnergyTable);		for (int i=0;i<dimension;i++)			energy += penaltyTable[i] = getPenalty(dlmss[i], type);		return energy;	}		/************************************************************	 * ニュートン法で用いるgradとhesseとエネルギーを同時に計算  *	 ************************************************************/				/**	 * 一つの色を変数としたときの、微分と二次微分とエネルギーを計算する	 * @param dlmss 色盲の色の組	 * @param v 変更させる色の番号	 * @param grad 一次微分	 * @param hesse 二次微分	 * @param type 色盲タイプ	 * @return この色に関するエネルギー値	 */	public double energyGradHesse(LMS[] dlmss, int v, double[] grad, double[][] hesse, int type) {		double delta = 0, base = 0;		boolean contExist = desiredContrast != null,				distExist = desiredDistinguishability != null,				keepExist = desiredKeepability != null,				conDo /*, disDo */;		for(int i=0;i<2;i++) {			grad[i] = 0.0;			for (int j=0;j<2;j++)				hesse[i][j] = 0.0;		}		//複数の願望結果を足すための、キャッシュの初期化		for(int i=0;i<4;i++) desiredBase[i] = 0.0;		for(int i=0;i<3;i++) {			for (int j=0;j<2;j++) {				desiredGrad[i][j] = 0;				for(int k=0;k<2;k++) desiredHesse[i][j][k] = 0;			}		}		//色 v に関わる願望計算		for(int j=0;j<dimension;j++) {			if(conDo = (contExist && desiredContrast.gravity[v][j]>0)) {				delta = getDerivative(dlmss[v], dlmss[j], type, gradBase, gradSq, hesseBase, hesseSq);				desiredBase[0] = 					desiredContrast.energyGradHesse(							v,j,delta,gradBase,gradSq,hesseBase,hesseSq,desiredGrad[0],desiredHesse[0]);				base += desiredBase[0];				for (int k=0;k<2;k++) {					grad[k] += desiredGrad[0][k];					for (int l=0;l<2;l++) hesse[k][l] += desiredHesse[0][k][l];				}			}			if(distExist && desiredDistinguishability.gravity[v][j]>0) {				if (!conDo)					delta = getDerivative(dlmss[v], dlmss[j], type, gradBase, gradSq, hesseBase, hesseSq);				desiredBase[1] =					desiredDistinguishability.energyGradHesse(							v,j,delta,gradBase,gradSq,hesseBase,hesseSq,desiredGrad[1],desiredHesse[1]);				base += desiredBase[1];				for (int k=0;k<2;k++) {					grad[k] += desiredGrad[1][k];					for (int l=0;l<2;l++) hesse[k][l] += desiredHesse[1][k][l];				}			}		}		if(keepExist && desiredKeepability.gravity[v] > 0) {			desiredBase[2] =				desiredKeepability.energyGradHesse(v, dlmss[v], type, desiredGrad[2], desiredHesse[2]);			base += desiredBase[2];			for (int k=0;k<2;k++) {				grad[k] += desiredGrad[2][k];				for (int l=0;l<2;l++) hesse[k][l] += desiredHesse[2][k][l];			}		}		desiredBase[3] = getPenalty(dlmss[v], type, desiredGrad[3], desiredHesse[3]);		base += desiredBase[3];		for (int k=0;k<2;k++) {			grad[k] += desiredGrad[3][k];			for (int l=0;l<2;l++) hesse[k][l] += desiredHesse[3][k][l];		}		return base;	}				/************************************************************	 *    Mathematica で求めた式 による計算メソッド    **********	 ************************************************************/				static double Power(double x, int r) {		double pow = x;		for(int i=1;i<r;i++) pow*=x;		return pow;	}	static double Power(double x, double r) { return Math.pow(x,r);}	//xyzP={XP1, YP1, ZP1}などである。	private static void getPxyz(double m, double s, double[] xyzP, boolean isLong) {		assert xyzP.length==3;		double m1=m, s1=s;		if(isLong) {			xyzP[0]=4.075609687969952*m1 - 0.03440122529790246*s1;			xyzP[1]=4.283672203550259*m1 - 0.5272393916257512*s1;			xyzP[2]=0.023136033502101916*m1 + 6.081219191232801*s1;		}else{			xyzP[0]=4.703075091115781*m1 - 1.052765194353109*s1;			xyzP[1]=4.492826836384209*m1 - 0.8666932339749891*s1;			xyzP[2]=0.022992375942771842*m1 + 6.081452344617149*s1;		}	}	private static void getDxyz(double l, double s, double[] xyzD, boolean isLong) {		assert xyzD.length==3;		double l1=l, s1=s;		if(isLong) {			xyzD[0]=3.040416615941812*l1 + 0.5446660211104368*s1;			xyzD[1]=3.195631854386324*l1 + 0.08138961294935022*s1;			xyzD[2]=0.017259547913631254*l1 + 6.084506385110179*s1;		} else {			xyzD[0]=3.2833691050956775*l1 + 0.0623781711010174*s1;			xyzD[1]=3.136587986229435*l1 + 0.19859829160417636*s1;			xyzD[2]=0.016051722619919297*l1 + 6.086904053337905*s1;		}	}	private static void getTxyz(double l, double m, double[] xyzT, boolean isLong) {		assert xyzT.length==3;		double l1=l, m1=m;		if(isLong) {			xyzT[0]=6.758794482396471*l1 - 4.212453990079704*m1;			xyzT[1]=2.2805283404683605*l1 + 1.1694365118999697*m1;			xyzT[2]=-0.3269915993700789*l1 + 4.170034302268877*m1;		} else {			xyzT[0]=5.860131899428581*l1 - 3.1132750783014336*m1;			xyzT[1]=2.347163175068823*l1 + 1.0879336137368238*m1;			xyzT[2]=-4.644327347634536*l1 + 9.450686350656552*m1;		}	}	//YP1^(1/3) -> yp1_3 となるように引数をとること。	//xyz1_3 = {XP1^(.3), YP1^(.3), ZP1^(.3)}とすること。	private static void getPDTlab(double[] xyz1_3, double[] xyz2_3, double[] labPDT) {		assert xyz1_3.length==3 && xyz2_3.length==3 && labPDT.length==3;		double x1_13=xyz1_3[0],y1_13=xyz1_3[1],z1_13=xyz1_3[2],				x2_13=xyz2_3[0],y2_13=xyz2_3[1],z2_13=xyz2_3[2];		labPDT[0]=116.*y1_13 - 116.*y2_13;		labPDT[1]=1.0170842012987897*(x1_13 - x2_13) - y1_13 + y2_13;		labPDT[2]=1.*y1_13 - 1.*y2_13 +0.9720039023300496*(-z1_13 + z2_13);	}	private static double getPDTdelta(double[] labPDT) {		assert labPDT.length==3;		return 250000.*Power(labPDT[1],2) + 40000.*Power(labPDT[2],2) + Power(labPDT[0],2);	}	//yp_23 = YP1^(2/3) をセット済みのこと。	private static void getPDTf(double y_23, double[] fy, boolean isLong, int type) {		assert fy.length==2;		switch(type) {		case Dichromat.PROTANOPE:			if (isLong) {				fy[0]=1.4278907345167529/y_23;				fy[1]=0.1757464638752504/y_23;			} else {				fy[0]=1.497608945461403/y_23;				fy[1]=0.2888977446583297/y_23;			}			break;		case Dichromat.DEUTERANOPE:			if (isLong) {				fy[0]=1.0652106181287746/y_23;				fy[1]=0.02712987098311674/y_23;			} else {				fy[0]=1.0455293287431449/y_23;				fy[1]=0.06619943053472545/y_23;			}			break;		case Dichromat.TRITANOPE:			if (isLong) {				fy[0]=0.7601761134894535/y_23;				fy[1]=0.3898121706333232/y_23;			} else {				fy[0]=0.782387725022941/y_23;				fy[1]=0.3626445379122746/y_23;			}			break;		}	}	//fyp = {FYP1, FYP2}をセットすること。fFyp = {FFYP11, FFYP12, FFYP21, FFYP22}が入力される。	private static void getPDThF(double[] fy, double x_23, double z_23,			double[] fFy, boolean isLong, int type) {		assert fy.length==2 && fFy.length==4;		double FY1=fy[0], FY2=fy[1];		switch(type) {		case Dichromat.PROTANOPE:			if (isLong) {				fFy[0]=FY1 - 1.3817460747648427/x_23;				fFy[1]=FY1 - 0.007496104949493943/z_23;				fFy[2]=-FY2 + 0.011662980918605613/x_23;				fFy[3]=-FY2 - 1.970322928267557/z_23;			} else {				fFy[0]=-FY1 + 1.594474457565242/x_23;				fFy[1]=FY1 - 0.007449559713404595/z_23;				fFy[2]=FY2 - 0.35691694895126563/x_23;				fFy[3]=-FY2 - 1.9703984702673658/z_23;			}			break;		case Dichromat.DEUTERANOPE:			if (isLong) {				fFy[0]=FY1 - 1.0307865684802489/x_23;				fFy[1]=FY1 - 0.005592115974834015/z_23;				fFy[2]=FY2 - 0.18465706835189943/x_23;				fFy[3]=FY2 - 1.9713879833597325/z_23;			}else {				fFy[0]=-FY1 + 1.1131542812751196/x_23;				fFy[1]=FY1 - 0.005200779008560362/z_23;				fFy[2]=-FY2 + 0.02114795077758584/x_23;				fFy[3]=FY2 - 1.9721648309843465/z_23;			}			break;		case Dichromat.TRITANOPE:			if (isLong) {				fFy[0]=-FY1 + 2.2914210292902935/x_23;				fFy[1]=FY1 + 0.10594570353895362/z_23;				fFy[2]=-FY2 - 1.428140134002705/x_23;				fFy[3]=FY2 - 1.3510965382185045/z_23;			} else {				fFy[0]=-FY1 + 1.9867491908119594/x_23;				fFy[1]=FY1 + 1.5047681018663126/z_23;				fFy[2]=-FY2 - 1.0554876321458802/x_23;				fFy[3]=FY2 - 3.062034670845168/z_23;			}			break;		}	}	//delta345 = {delta3, delta4, delta5}	private static void getDelta3(double[] labPDT, double[] fFy, double y_43,			double[] xyz_53, double[] delta345, boolean isLong, int type) {		assert delta345.length==3 && fFy.length==4;		double x_53 = xyz_53[0], y_53 = xyz_53[1], z_53 = xyz_53[2];		switch(type) {		case Dichromat.PROTANOPE:			double FFYP11=fFy[0], FFYP12=fFy[1], FFYP21=fFy[2], FFYP22=fFy[3],					LP=labPDT[0], AP=labPDT[1], BP=labPDT[2];			if(isLong) {				delta345[0]=500000.*Power(FFYP11,2) + 80000.*Power(FFYP12,2) - 				     500000.*AP*(3.7543051257506974/x_53 - 				        4.077743899437584/y_53) - 				     (946.0365846695195*LP)/y_53 + 				     54870.121910832124/y_43 + 				     80000.*BP*(-4.077743899437584/y_53 + 				        0.00011562009016450924/z_53);				delta345[1]=500000.*FFYP11*FFYP21 + 80000.*FFYP12*FFYP22 - 				     500000.*AP*(-0.031689172014985154/x_53 + 				        0.5018934947831065/y_53) + 				     (116.43929078968071*LP)/y_53 - 				     6753.47886580148/y_43 + 				     80000.*BP*(0.5018934947831065/y_53 + 				        0.0303903048522385/z_53);				delta345[2]=500000.*Power(FFYP21,2) + 80000.*Power(FFYP22,2) - 				     500000.*AP*(0.00026748055615072607/x_53 - 				        0.06177363912930938/y_53) - 				     (14.331484277999776*LP)/y_53 + 				     831.2260881239871/y_43 + 				     80000.*BP*(-0.06177363912930938/y_53 + 				        7.987977069537784/z_53);			} else {				delta345[0]=500000.*Power(FFYP11,2) + 80000.*Power(FFYP12,2) + 					     500000.*AP*(-4.99928873653029/x_53 + 					        4.485665107052031/y_53) - 					     (1040.674304836071*LP)/y_53 + 					     60359.109680492125/y_43 + 					     80000.*BP*(-4.485665107052031/y_53 + 					        0.00011418871835915074/z_53);				delta345[1]=500000.*FFYP11*FFYP21 + 80000.*FFYP12*FFYP22 + 					     500000.*AP*(1.1190714748064932/x_53 - 					        0.8653116934478776/y_53) + 					     (200.75231287990758*LP)/y_53 - 					     11643.634147034642/y_43 + 					     80000.*BP*(0.8653116934478776/y_53 + 					        0.03020276159029988/z_53);				delta345[2]=500000.*Power(FFYP21,2) + 80000.*Power(FFYP22,2) + 					     500000.*AP*(-0.2504998274203985/x_53 + 					        0.16692381373733892/y_53) - 					     (38.72632478706263*LP)/y_53 + 					     2246.1268376496328/y_43 + 					     80000.*BP*(-0.16692381373733892/y_53 + 					        7.988589597891675/z_53);			}			break;		case Dichromat.DEUTERANOPE:			double FFYD11=fFy[0], FFYD12=fFy[1], FFYD21=fFy[2], FFYD22=fFy[3],					LD=labPDT[0], AD=labPDT[1], BD=labPDT[2];			if(isLong) {				delta345[0]=500000.*Power(FFYD11,2) + 80000.*Power(FFYD12,2) - 					     500000.*AD*(2.089347073531327/x_53 - 					        2.269347321948572/y_53) - 					     (526.4885786920687*LD)/y_53 + 					     30536.337564139987/y_43 + 					     80000.*BD*(-2.269347321948572/y_53 + 					        0.00006434492907082028/z_53);				delta345[1]=500000.*FFYD11*FFYD21 + 80000.*FFYD12*FFYD22 - 					     500000.*AD*(0.37428961257881194/x_53 - 					        0.05779805327935938/y_53) - 					     (13.409148360811376*LD)/y_53 + 					     777.7306049270599/y_43 + 					     80000.*BD*(-0.05779805327935938/y_53 + 					        0.022683510236769462/z_53);				delta345[2]=500000.*Power(FFYD21,2) + 80000.*Power(FFYD22,2) - 					     500000.*AD*(0.06705095379276468/x_53 - 					        0.0014720597991211195/y_53) - 					     (0.34151787339609974*LD)/y_53 + 					     19.808036656973783/y_43 + 					     80000.*BD*(-0.0014720597991211195/y_53 + 					        7.996615181521181/z_53);			} else {				delta345[0]=500000.*Power(FFYD11,2) + 80000.*Power(FFYD12,2) + 					     500000.*AD*(-2.436597584229141/x_53 + 					        2.186263154524182/y_53) - 					     (507.2130518496102*LD)/y_53 + 					     29418.35700727739/y_43 + 					     80000.*BD*(-2.186263154524182/y_53 + 					        0.000055654308035273205/z_53);				delta345[1]=500000.*FFYD11*FFYD21 + 80000.*FFYD12*FFYD22 + 					     500000.*AD*(-0.046291018812806305/x_53 + 					        0.1384268923402999/y_53) - 					     (32.115039022949574*LD)/y_53 + 					     1862.672263331075/y_43 + 					     80000.*BD*(-0.1384268923402999/y_53 + 					        0.021104428551813836/z_53);				delta345[2]=500000.*Power(FFYD21,2) + 80000.*Power(FFYD22,2) + 					     500000.*AD*(-0.0008794469946934291/x_53 + 					        0.00876472920624388/y_53) - 					     (2.03341717584858*LD)/y_53 + 					     117.93819619921764/y_43 + 					     80000.*BD*(-0.00876472920624388/y_53 + 					        8.00291873571272/z_53);			}			break;		case Dichromat.TRITANOPE:			double FFYT11=fFy[0], FFYT12=fFy[1], FFYT21=fFy[2], FFYT22=fFy[3],					LT=labPDT[0], AT=labPDT[1], BT=labPDT[2];			if(isLong) {				delta345[0]=500000.*Power(FFYT11,2) + 80000.*Power(FFYT12,2) + 					     500000.*AT*(-10.324829206409651/x_53 + 					        1.1557354470398609/y_53) - 					     (268.1306237132477*LT)/y_53 + 					     15551.576175368366/y_43 + 					     80000.*BT*(-1.1557354470398609/y_53 + 					        0.023095570031060445/z_53);				delta345[1]=500000.*FFYT11*FFYT21 + 80000.*FFYT12*FFYT22 + 					     500000.*AT*(6.435003771857625/x_53 + 					        0.5926518017258545/y_53) - 					     (137.49521800039827*LT)/y_53 + 					     7974.722644023099/y_43 + 					     80000.*BT*(-0.5926518017258545/y_53 - 					        0.29453147862363044/z_53);				delta345[2]=500000.*Power(FFYT21,2) + 80000.*Power(FFYT22,2) + 					     500000.*AT*(-4.010649737248437/x_53 + 					        0.30390705674772617/y_53) - 					     (70.50643716547248*LT)/y_53 + 					     4089.3733555974036/y_43 + 					     80000.*BT*(-0.30390705674772617/y_53 + 					        3.756079273365264/z_53);			} else {				delta345[0]=500000.*Power(FFYT11,2) + 80000.*Power(FFYT12,2) + 					     500000.*AT*(-7.761741539494056/x_53 + 					        1.2242611045331462/y_53) - 					     (284.0285762516899*LT)/y_53 + 					     16473.657422598015/y_43 + 					     80000.*BT*(-1.2242611045331462/y_53 + 					        4.659090431563884/z_53);				delta345[1]=500000.*FFYT11*FFYT21 + 80000.*FFYT12*FFYT22 + 					     500000.*AT*(4.123531161726942/x_53 + 					        0.5674572700183603/y_53) - 					     (131.6500866442596*LT)/y_53 + 					     7635.705025367057/y_43 + 					     80000.*BT*(-0.5674572700183603/y_53 - 					        9.480727574140886/z_53);				delta345[2]=500000.*Power(FFYT21,2) + 80000.*Power(FFYT22,2) + 					     500000.*AT*(-2.190682227076773/x_53 + 					        0.26302212175521433/y_53) - 					     (61.021132247209714*LT)/y_53 + 					     3539.225670338163/y_43 + 					     80000.*BT*(-0.26302212175521433/y_53 + 					        19.29221951266237/z_53);			}			break;		}	}	//yp_23 = YP1^(2/3)	private static void getPhDelta(double[] labPDT, double[] fFy, double y_23,			double[] hDelta, boolean isLong, int type) {		assert labPDT.length==3 && fFy.length==4 && hDelta.length==2;		double FFY11=fFy[0], FFY12=fFy[1], FFY21=fFy[2], FFY22=fFy[3],				LPDT=labPDT[0], APDT=labPDT[1], BPDT=labPDT[2];		switch(type) {		case Dichromat.PROTANOPE:			if(isLong) {				hDelta[0]=-500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (331.27065040788665*LPDT)/y_23;				hDelta[1]=-500000.*APDT*FFY21 + 80000.*BPDT*FFY22 - 					     (40.77317961905809*LPDT)/y_23;			} else {				hDelta[0]=500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (347.4452753470455*LPDT)/y_23;							hDelta[1]=500000.*APDT*FFY21 + 80000.*BPDT*FFY22 - 					     (67.02427676073249*LPDT)/y_23;			}			break;		case Dichromat.DEUTERANOPE:			if (isLong) {				hDelta[0]=-500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (247.1288634058757*LPDT)/y_23;				hDelta[1]=-500000.*APDT*FFY21 + 80000.*BPDT*FFY22 + 					     (6.294130068083084*LPDT)/y_23;			} else {				hDelta[0]=500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (242.5628042684096*LPDT)/y_23;							hDelta[1]=500000.*APDT*FFY21 + 80000.*BPDT*FFY22 + 					     (15.358267884056303*LPDT)/y_23;			}			break;		case Dichromat.TRITANOPE:			if (isLong) {				hDelta[0]=500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (176.3608583295532*LPDT)/y_23;				hDelta[1]=500000.*APDT*FFY21 + 80000.*BPDT*FFY22 + 					     (90.43642358693099*LPDT)/y_23;			} else {				hDelta[0]=500000.*APDT*FFY11 + 80000.*BPDT*FFY12 + 					     (181.5139522053223*LPDT)/y_23;							hDelta[1]=500000.*APDT*FFY21 + 80000.*BPDT*FFY22 + 					     (84.1335327956477*LPDT)/y_23;			}			break;		}	}	// delta=(pDelta,dDelta,tDelta),  hDelta=(phDelta,dhDelta,thDelta)	private static void gradDelta(double delta_12, double[] hDelta, double[] grad) {		assert hDelta.length==2 && grad.length==2;		double delta_12_2 = 2*delta_12;		grad[0]=hDelta[0]/delta_12_2;		grad[1]=hDelta[1]/delta_12_2;	}	private static void hesseDelta(double delta_12, double delta_32, double[] hDelta, double[] delta345, double[][] hesse) {		assert hDelta.length==2 && delta345.length==3 && hesse.length==2;		double hDelta1=hDelta[0], hDelta2=hDelta[1],				delta3=delta345[0], delta4=delta345[1], delta5=delta345[2],				delta_12_2 = 2 * delta_12, delta_32_4 = 4 * delta_32;		hesse[0][0]=delta3/delta_12_2 - Power(hDelta1,2)/delta_32_4;		hesse[0][1]=delta4/delta_12_2 - (hDelta1*hDelta2)/delta_32_4;		hesse[1][0]=hesse[0][1];		hesse[1][1]=delta5/delta_12_2 - Power(hDelta2,2)/delta_32_4;	}	private static void gradDeltaSq(double[] hDelta, double[] grad) {		assert hDelta.length==2 && grad.length==2;		grad[0]=hDelta[0];		grad[1]=hDelta[1];	}	private static void hesseDeltaSq(double[] delta345, double[][] hesse) {		assert delta345.length==3 && hesse.length==2;		hesse[0][0]=delta345[0]; hesse[0][1]=delta345[1];		hesse[1][0]=hesse[0][1]; hesse[1][1]=delta345[2];	}	/**	 * ペナルティ関数を用いた、SRGB空間による境界判定	 * @param dlms 色盲の色	 * @param isLong 色盲平面の選択	 * @param type 色盲タイプ	 * @return	 */	public static boolean boundaryCheck(LMS dlms, boolean isLong, int type) {		double[][][] penaltyRGBLMS = isLong ? PenaltyRGBLMSLong : PenaltyRGBLMSShort;		boolean boundaryOK = true;				// ms1 = PROTANOPE:{dlms.M, dlms.S, 1} DEUTERANOPE:{dlms.L, dlms.S, 1}		int val = 0;		for(int i=0;i<3;i++) {			if(i!=type-1) ms1[val++] = dlms.getValue(i);		}		ms1[2] = 1;				// ペナルティ関数で用いた Log の中身 （これが正であれば境界の内側である） の計算		for (int i=0;i<6;i++) {			aMbSc[i] = 0.0;			for (int j=0;j<3;j++) {				abc[i][j] = penaltyRGBLMS[type-1][i][j];				aMbSc[i] += abc[i][j]*ms1[j];			}			if(aMbSc[i]<smallNum) boundaryOK = false;		}		return boundaryOK;	}		public static double getPenalty(LMS lms, int type, double[] grad, double[][] hesse) {		double penalty = 0.0;		for(int i=0;i<2;i++) {			grad[i] = 0.0;			for(int j=0;j<2;j++)				hesse[i][j] = 0.0;		}		boolean isLong = Dichromat.choiceAnchor(lms, type);		double[][][] penaltyRGBLMS = isLong ? PenaltyRGBLMSLong : PenaltyRGBLMSShort;		int val=0;		for (int i=0;i<3;i++) {			if (i!=type-1) {				ms1[val] = lms.getValue(i);				val++;			}		}		ms1[2] = 1;		for (int i=0;i<2;i++) {			grad[i] = 0.0;			for (int j=0;j<2;j++) hesse[i][j] = 0.0;		}		for (int i=0;i<6;i++) {			aMbSc[i] = 0.0;			for (int j=0;j<3;j++) {				abc[i][j] = penaltyRGBLMS[type-1][i][j];				aMbSc[i] += abc[i][j]*ms1[j];			}			if(aMbSc[i]<smallNum) aMbSc[i]=smallNum;			penalty += penaltyBase[i] = -Math.log(aMbSc[i]);			for (int j=0;j<2;j++) {				grad[j] += penaltyGrad[i][j] = -abc[i][j]/aMbSc[i];				for (int k=0;k<2;k++) hesse[j][k] += penaltyHesse[i][j][k] = abc[i][j]*abc[i][k]/Power(aMbSc[i],2);			}		}		return penalty;	}		public static double getDerivative(LMS lms1, LMS lms2, int type,											double[] grad, double[] gradSq, double[][] hesse, double[][] hesseSq) {		double l1=lms1.getValue1(), m1=lms1.getValue2(), s1=lms1.getValue3(),				l2=lms2.getValue1(), m2=lms2.getValue2(), s2=lms2.getValue3(),				delta, delta_12, delta_32, y_23, y_43;		boolean isLong1 = Dichromat.choiceAnchor(lms1, type);		boolean isLong2 = Dichromat.choiceAnchor(lms2, type);		switch(type) {		case Dichromat.PROTANOPE:			getPxyz(m1, s1, xyzPDT1, isLong1);			getPxyz(m2, s2, xyzPDT2, isLong2);			break;		case Dichromat.DEUTERANOPE:			getDxyz(l1, s1, xyzPDT1, isLong1);			getDxyz(l2, s2, xyzPDT2, isLong2);			break;		case Dichromat.TRITANOPE:			getTxyz(l1, m1, xyzPDT1, isLong1);			getTxyz(l2, m2, xyzPDT2, isLong2);			break;		}		for(int i=0;i<3;i++) {			if(xyzPDT1[i]<smallNum) xyzPDT1[i]=smallNum;			if(xyzPDT2[i]<smallNum) xyzPDT2[i]=smallNum;			xyz1_13[i]=Power(xyzPDT1[i], 0.3333333333333333);//XP1^(1/3)...			xyz2_13[i]=Power(xyzPDT2[i], 0.3333333333333333);//XP2^(1/3)...			xyz_23[i]=Power(xyz1_13[i], 2);			xyz_53[i]=xyz_23[i]*xyzPDT1[i];		}		getPDTlab(xyz1_13, xyz2_13, labPDT);		delta = getPDTdelta(labPDT);		delta_12 = Math.sqrt(delta);		delta_32 = delta * delta_12;		y_23 = xyz_23[1];		y_43 = Power(y_23, 2);				getPDTf(y_23, fy, isLong1, type);		getPDThF(fy,xyz_23[0], xyz_23[2], fFy, isLong1, type);		getPhDelta(labPDT, fFy, y_23, hDelta, isLong1, type);		getDelta3(labPDT, fFy, y_43, xyz_53, delta345, isLong1, type);		gradDelta(delta_12, hDelta, grad);		hesseDelta(delta_12, delta_32, hDelta, delta345, hesse);		gradDeltaSq(hDelta, gradSq);		hesseDeltaSq(delta345, hesse);		return delta_12;	}	/**	 * 色盲化した色の色差計算	 * @param lms1 色盲の色１	 * @param lms2 色盲の色２	 * @param type 色盲タイプ	 * @return	 */	public static double deltaDICHROLMS(LMS lms1, LMS lms2, int type) {		double l1=lms1.getValue1(), m1=lms1.getValue2(), s1=lms1.getValue3(),				l2=lms2.getValue1(), m2=lms2.getValue2(), s2=lms2.getValue3();		boolean isLong1 = Dichromat.choiceAnchor(lms1, type);		boolean isLong2 = Dichromat.choiceAnchor(lms2, type);		switch(type) {		case Dichromat.PROTANOPE:			getPxyz(m1, s1, xyzPDT1, isLong1);			getPxyz(m2, s2, xyzPDT2, isLong2);			break;		case Dichromat.DEUTERANOPE:			getDxyz(l1, s1, xyzPDT1, isLong1);			getDxyz(l2, s2, xyzPDT2, isLong2);			break;		case Dichromat.TRITANOPE:			getTxyz(l1, m1, xyzPDT1, isLong1);			getTxyz(l2, m2, xyzPDT2, isLong2);			break;		}		for(int i=0;i<3;i++) {			if(xyzPDT1[i]<smallNum) xyzPDT1[i]=smallNum;			if(xyzPDT2[i]<smallNum) xyzPDT2[i]=smallNum;			xyz1_13[i]=Power(xyzPDT1[i], 0.3333333333333333);//XP1^(1/3)...			xyz2_13[i]=Power(xyzPDT2[i], 0.3333333333333333);//XP2^(1/3)...		}		getPDTlab(xyz1_13, xyz2_13, labPDT);		return Math.sqrt(getPDTdelta(labPDT));	}	/**	 * 読み込みメソッド。次元数と願望３種を読み込む	 * @param in	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void readObject(ObjectInputStream in) 	throws IOException, ClassNotFoundException{		dimension = in.readInt();		desiredContrast = (DesiredContrast)in.readObject();		desiredDistinguishability = (DesiredDistinguishability)in.readObject();		desiredKeepability = (DesiredKeepability)in.readObject();	}	/**	 * 保存メソッド。次元数と願望３種を保存	 * @param out	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void writeObject(ObjectOutputStream out)	throws IOException, ClassNotFoundException {		out.writeInt(dimension);		out.writeObject(desiredContrast);		out.writeObject(desiredDistinguishability);		out.writeObject(desiredKeepability);	}}