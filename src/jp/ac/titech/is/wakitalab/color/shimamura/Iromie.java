/* * 作成日: 2004/05/17 * * この生成されたコメントの挿入されるテンプレートを変更するため * ウィンドウ > 設定 > Java > コード生成 > コードとコメント */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.*;import java.util.*;import java.util.List;import java.awt.*;import java.awt.image.*;import java.awt.event.*;import javax.imageio.*;import javax.swing.JFrame;import javax.xml.parsers.*;import javax.xml.transform.*;import javax.xml.transform.dom.*;import javax.xml.transform.stream.*;import org.w3c.dom.*;/** * @author shinamu1 * * この生成されたコメントの挿入されるテンプレートを変更するため * ウィンドウ > 設定 > Java > コード生成 > コードとコメント */public class Iromie {		final static int DISTINGUISH = 0, CONTRAST = 1, KEEP = 2;	final static int DEFAULT_H=400, DEFAULT_W=600, DEFAULT_SIDE=75;	private int[][] pixels;	private int[][] originalPixels;	private int[][] medianPixels;	private int[][] filteredPixels;	private int[][] colorReducePixels;	private int[][] areaPixels;	private int h,w;	public boolean fixNaturalColoring = true;	public int fixNaturalColoringBorder = 100;//今後はfixかunfixの選択式に。	//彩色文書の色情報 色のIDと塗る色のキャッシュを保存する	private ColorOBJ[] colorOBJ;	//ColorOBJ[]を作成したかどうか。	boolean colorUnificationBoolean;	int[][] colorOBJIdMatrix;	//ColorOBJの数	private int colorOBJNum;	//彩色文書の領域情報	private AreaOBJ[] areaOBJ;	//AreaOBJの数	private int areaOBJNum;	// Optimized-Lab.  for Return	private Lab[] optimizedLab;	//重要度係数 色＊色	private double[][] distinguishGravity, contrastGravity;	private double[] keepGravity;	// Simulated Annealing 情報	SimulatedAnnealing sa;	// Newton Raphson 情報	Newton nr;	//実験情報管理オブジェクト	Vector<MinimizeExperiment> expVector = new Vector<MinimizeExperiment>();	int expNumMax = 0;	//いま扱っている実験状態 この実験状態の色がColorOBJに入っている。	int activeExpNum = -1;		CompoundDesire compoundDesire;	DesiredDistinguishability dDesire;	DesiredContrast cDesire;	DesiredKeepability kDesire;	Lab[] conIdealLabs, keepIdealLabs;		SRGB tempSRGB = new SRGB();		// the default Simulated Annealing parameter	int defCountMax = 100;	double defE = 0.01;	double defJump = 10.0;	double defJumpCold = 0.5;	double defTemperture = 100000.0;	double defTempertureCold = 0.99;	int testLoopMax = 150000;	/**	 * 	 */	public Iromie() {		colorUnificationBoolean = false;		colorOBJNum = 0;		areaOBJNum = 0;	}		/**	 * 画像の読み直しをするときなどの初期化	 */	private void dataClear() {		pixels = null;		originalPixels = null;		medianPixels = null;		filteredPixels = null;		colorReducePixels = null;		areaPixels = null;		colorOBJIdMatrix = null;		areaOBJ = null;		colorOBJ = null;		colorUnificationBoolean = false;		colorOBJNum = 0;		areaOBJNum = 0;		distinguishGravity = null;		contrastGravity = null;		keepGravity = null;	}		/**	 * K クラスタリングをやり直すときなどの初期化	 */	void unificationClear() {		areaOBJ = null;		colorOBJ = null;		colorOBJIdMatrix = null;		colorUnificationBoolean = false;		colorOBJNum = 0;		areaOBJNum = 0;		distinguishGravity = null;		contrastGravity = null;		keepGravity = null;	}		/**	 * Bitmapファイルを読み込みPixelの列を手に入れる。	 */	public void readBitmap(String fileName){		dataClear();		Bitmap bmp = new Bitmap(fileName);		originalPixels = bmp.getBMPSource2();		h = bmp.getHeight();		w = bmp.getWidth();	}		/**	 * Jpegファイルを読み込みPixelの列を手に入れる。	 */	public void readJpeg(String fileName){		dataClear();		try {			File file = new File(fileName);			BufferedImage image = ImageIO.read(file);			h = image.getHeight();			w = image.getWidth();			originalPixels = new int[h][w];			for (int i=0;i<h;i++) {				for (int j=0;j<w;j++) {					originalPixels[i][j] = image.getRGB(j,i);				}			}		} catch (Exception e) {			System.out.println("io errer." + e);		}	}		/**	 * テキストの画像情報から彩色文書を手に入れる。	 */	public void readTextColoringInformation(String fileName){		dataClear();		try {			//ファイル読み込み			FileReader fr = new FileReader(fileName);			BufferedReader br = new BufferedReader(fr);			String line;			int addNum, lastIndex;			//colorOBJ初期化			colorOBJNum = Integer.parseInt(br.readLine());//色数			colorOBJ = new ColorOBJ[colorOBJNum];			System.out.println("色数をセットしました：" + colorOBJNum);			for (int i=0;i<colorOBJNum;i++) {				colorOBJ[i] = new ColorOBJ(i);			}			//areaOBJ初期化			areaOBJNum = Integer.parseInt(br.readLine());//領域の数			areaOBJ = new AreaOBJ[areaOBJNum];			System.out.println("領域数をセットしました：" + areaOBJNum);			for (int i=0;i<areaOBJNum;i++) {				areaOBJ[i] = new AreaOBJ(i);			}			//areaPixels初期化			h = DEFAULT_H;			w = DEFAULT_W;			areaPixels = new int[h][w];			// pixels の初期化			originalPixels = new int[h][w];						/*			 * colorOBJと領域への参照の初期化			 */			int colorNum = 0;			while((line=br.readLine()) != null){				lastIndex = line.indexOf(";");				addNum = Integer.parseInt(line.substring(0,lastIndex), 16);				colorOBJ[colorNum].setFirstSRGB(addNum);				colorOBJ[colorNum].prepareAddAreaV();				System.out.print("色" + addNum);				line = line.substring(lastIndex+1);				while((lastIndex=line.indexOf(";"))>0) {					addNum = Integer.parseInt(line.substring(0,lastIndex));					colorOBJ[colorNum].addAreaV(areaOBJ[addNum]);					areaOBJ[addNum].setColorOBJ(colorOBJ[colorNum]);					System.out.print("領域" + addNum);					line = line.substring(lastIndex+1);				}				colorOBJ[colorNum].endAddAreaV();				System.out.print("\n");				if (!(++colorNum<colorOBJNum)) {					break;				}			}			/*			 * pixelsの領域への参照配列の生成			 */			int areaNum = 0;			int side = DEFAULT_SIDE;			int ww = w/side, hh = h/side;			ii_for :{				for (int ii=0;ii<hh;ii++) {					for (int jj=0;jj<ww;jj++) {						for (int i=ii*side;i<(ii+1)*side;i++) {							for (int j=jj*side;j<(jj+1)*side;j++) {								areaPixels[i][j] = areaNum;							}							}						if (!(++areaNum < areaOBJNum)) {							break ii_for;						}					}				}			}			// originalPixels にも画像をセットする。			for (int i=0;i<h;i++) {				for (int j=0;j<w;j++) {					originalPixels[i][j] = areaOBJ[areaPixels[i][j]].getColorOBJ().getFirstSRGB().getInt();				}			}			/*			 * Distinguish,Contrast,Keepの重要度係数の初期化			 */			distinguishGravity = new double[colorOBJNum][colorOBJNum];			contrastGravity = new double[colorOBJNum][colorOBJNum];			keepGravity = new double[colorOBJNum];			//Distinguish係数読み込み			System.out.println("Distinguish:");			for(int i=0;i<colorOBJNum;i++) {				line = br.readLine();				int j = 0;				while(((lastIndex=line.indexOf(";")) > 0) && (j < colorOBJNum)) {					addNum = Integer.parseInt(line.substring(0,lastIndex));					System.out.print("("+i+","+j+")"+addNum+":");					setDistinguishGravity(i,j++,(double)addNum);					line = line.substring(lastIndex+1);				}			}			System.out.print("\n");			//Contrast係数読み込み			System.out.println("Contrast:");			for (int i=0;i<colorOBJNum;i++) {				line = br.readLine();				int j = 0;				while(((lastIndex=line.indexOf(";")) > 0) && (j < colorOBJNum)) {					addNum = Integer.parseInt(line.substring(0,lastIndex));					System.out.print("("+i+","+j+")"+addNum+":");					setContrastGravity(i,j++,(double)addNum);					line = line.substring(lastIndex+1);				}			}			System.out.print("\n");			//Keep係数読み込み			System.out.println("Keep:");			for (int i=0;i<colorOBJNum;i++) {				line = br.readLine();				addNum = Integer.parseInt(line);				setKeepGravity(i,(double)addNum);				System.out.print("("+i+")"+addNum+":");			}			System.out.print("\n");						colorUnificationBoolean = true;			br.close();			fr.close();		} catch (Exception e) {			System.out.println("Exception in ColoringInformation.readColorFile(): "+e);		}	}	/**	 * 彩色文書を保存する	 * @param fileName	 */	public void saveXML(String fileName) {		try {			//XMLに準拠した言語を作る方法を調べましょう			DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); 			DocumentBuilder builder = factory.newDocumentBuilder(); 			DOMImplementation domImpl = builder.getDOMImplementation();			// ルート要素を作成			Document document = domImpl.createDocument("", "colorText", null);			Element colorText = document.getDocumentElement();						for (int k=0;k<expNumMax;k++) {				Element expElement = document.createElement("exp");				expElement.setAttribute("expNum", String.valueOf(k));				MinimizeExperiment exp = (MinimizeExperiment)expVector.get(k);				expElement.setAttribute("energy", String.valueOf(exp.getEnergy()));				colorText.appendChild(expElement);				for (int i=0;i<colorOBJNum;i++) {				// 色を追加					Element colorElement = document.createElement("colorElement");					colorElement.setAttribute("srgb", String.valueOf(colorOBJ[i].getOptimizedSRGB().getInt()));					expElement.appendChild(colorElement);				}			}			// 生成したXMLをファイルに保存			TransformerFactory transFactory = TransformerFactory.newInstance();			Transformer transformer = transFactory.newTransformer();			DOMSource source = new DOMSource(document);			File file = new File(fileName); 			FileOutputStream out = new FileOutputStream(file); 			StreamResult result = new StreamResult(out); 			transformer.transform(source, result);			//out.close();		} catch (Exception e) {			System.out.println("Exception :"+e);		}	}	// 図形の属性を要素として追加	public void appendElement(Document document, Element parent, String name, String value) {		Element element = document.createElement(name);		element.appendChild(document.createTextNode(value));		parent.appendChild(element);    }	/**	 * 色と願望と図を保存	 * @param fileName	 */	public void saveState(String fileName) {		try {			FileOutputStream fos = new FileOutputStream(fileName);			ObjectOutputStream out = new ObjectOutputStream(fos);			out.writeInt(colorOBJNum);			for(int i=0;i<colorOBJNum;i++) out.writeObject(colorOBJ[i]);			out.writeInt(expNumMax);			for(int i=0;i<expNumMax;i++) {				MinimizeExperiment exp = (MinimizeExperiment)expVector.get(i);				out.writeObject(exp.dlmss);				out.writeObject(exp.expCompoundDesire);				out.writeObject(exp.fixColoring);				out.writeInt(exp.type);			}			out.writeObject(colorOBJIdMatrix);		} catch(Exception e) {			System.out.println("Exception at Iromie.saveState(String) : "+e);		}	}	/**	 * 色と願望と図を読み込み	 * @param fileName	 */	public void loadState(String fileName) {		try {			FileInputStream fis = new FileInputStream(fileName);			ObjectInputStream in = new ObjectInputStream(fis);			colorOBJNum = in.readInt();			colorOBJ = new ColorOBJ[colorOBJNum];			for(int i=0;i<colorOBJNum;i++) colorOBJ[i] = (ColorOBJ)in.readObject();			expNumMax = in.readInt();			SRGB[] tempSRGBs = new SRGB[colorOBJNum];			for(int i=0;i<colorOBJNum;i++) tempSRGBs[i] = new SRGB();			for(int thisExpID=0;thisExpID<expNumMax;thisExpID++) {				LMS[] dlmss = (LMS[])in.readObject();				CompoundDesire compDesire = (CompoundDesire)in.readObject();				boolean[] fix = (boolean[])in.readObject();				int type = in.readInt();/*				LMS[] dlmss = new LMS[colorOBJNum];				getOptimizedSRGB(thisExpID, tempSRGBs);				for (int j=0;j<colorOBJNum;j++) dlmss[j] = tempSRGBs[thisExpID].getLMS();*/				MinimizeExperiment exp = new MinimizeExperiment(dlmss, compDesire, fix, type);				expVector.add(exp);			}			colorOBJIdMatrix = (int[][])in.readObject();/*			contrastGravity = compoundDesire.getContGravity();			distinguishGravity = compoundDesire.getDistGravity();			keepGravity = compoundDesire.getKeepGravity();*/			h = colorOBJIdMatrix.length;			w = colorOBJIdMatrix[0].length;			colorUnificationBoolean = true;		} catch (Exception e) {			System.out.println("Exception at Iromie.loadState(String) : "+e);		}	}/**	 * 中央値フィルター	 * 	 * オリジナルの画像をフィルタリングする	 */	public void medianFilter(){		if (medianPixels == null) {			medianPixels = new int[h][w];		}		int[][] tempMedianPixels = new int[h][w];		List<Integer> list = new ArrayList<Integer>();		Object obj;		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				if (i>0 && i<h-1 && j>0 && j<w-1) {					list.add(new Integer(pixels[i-1][j-1]));					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i-1][j+1]));					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					list.add(new Integer(pixels[i+1][j-1]));					list.add(new Integer(pixels[i+1][j]));					list.add(new Integer(pixels[i+1][j+1]));					Collections.sort(list);					obj = list.get(4);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==0 && j>0 && j<w-1) {					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					list.add(new Integer(pixels[i+1][j-1]));					list.add(new Integer(pixels[i+1][j]));					list.add(new Integer(pixels[i+1][j+1]));					Collections.sort(list);					obj = list.get(2);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==h-1 && j>0 && j<w-1) {					list.add(new Integer(pixels[i-1][j-1]));					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i-1][j+1]));					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					Collections.sort(list);					obj = list.get(2);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (j==0 && i>0 && i<h-1) {					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i-1][j+1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					list.add(new Integer(pixels[i+1][j]));					list.add(new Integer(pixels[i+1][j+1]));					Collections.sort(list);					obj = list.get(4);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (j==w-1 && i>0 && i<h-1) {					list.add(new Integer(pixels[i-1][j-1]));					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i+1][j-1]));					list.add(new Integer(pixels[i+1][j]));					Collections.sort(list);					obj = list.get(4);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==0 && j==0) {					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					list.add(new Integer(pixels[i+1][j]));					list.add(new Integer(pixels[i+1][j+1]));					Collections.sort(list);					obj = list.get(1);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==0 && j==w-1) {					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i+1][j-1]));					list.add(new Integer(pixels[i+1][j]));					Collections.sort(list);					obj = list.get(1);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==h-1 && j==0) {					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i-1][j+1]));					list.add(new Integer(pixels[i][j]));					list.add(new Integer(pixels[i][j+1]));					Collections.sort(list);					obj = list.get(1);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				} else if (i==h-1 && j==w-1) {					list.add(new Integer(pixels[i-1][j-1]));					list.add(new Integer(pixels[i-1][j]));					list.add(new Integer(pixels[i][j-1]));					list.add(new Integer(pixels[i][j]));					Collections.sort(list);					obj = list.get(1);					tempMedianPixels[i][j] = ((Integer)obj).intValue();				}				list.clear();			}		}		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				medianPixels[i][j] = tempMedianPixels[i][j];			}		}	}	/**	 * フィルタリング	 * @param filter	 * @param size	 */	private void normalFilter(int[][] filter, int size) {		if (filteredPixels == null) {			filteredPixels = new int[h][w];		}		int size2 = size/2 /*, sizeSize = size * size*/;		int rTemp, gTemp, bTemp, pi, pj;		for (int i=size2;i<h-size2;i++) {			for (int j=size2;j<w-size2;j++) {				rTemp = 0;				gTemp = 0;				bTemp = 0;				for (int ii=0;ii<size;ii++) {					pi = i-size2+ii;					for (int jj=0;jj<size;jj++) {						pj = j-size2+jj;						rTemp += filter[ii][jj] * ((pixels[pi][pj] >> 16) & 0x000000ff);						gTemp += filter[ii][jj] * ((pixels[pi][pj] >> 8) & 0x000000ff);						bTemp += filter[ii][jj] * (pixels[pi][pj] & 0x000000ff);					}				}				if (rTemp<0) {					rTemp = rTemp * (-1);				}				if (rTemp>255) {					rTemp = 255;				}				if (gTemp<0) {					gTemp = gTemp * (-1);				}				if (gTemp>255) {					gTemp = 255;				}				if (bTemp<0) {					bTemp = bTemp * (-1);				}				if (bTemp>255) {					bTemp = 255;				}				filteredPixels[i][j] =				(0xff000000 | (rTemp << 16) | (gTemp << 8) | bTemp);			}		}	}	/**	 * ３×３　４方向　ラプラシアンフィルター	 */	void laplacian34Filter() {		int[][] filter = 		{{0,1,0},		 {1,-4,1},		 {0,1,0}};		normalFilter(filter, 3);	}	/**	 * ３×３　８方向　ラプラシアンフィルター	 */	void laplacian38Filter() {		int[][] filter = 		{{1,1,1},		 {1,-8,1},		 {1,1,1}};		normalFilter(filter, 3);	}	/**	 * ９×９　８方向　ラプラシアンフィルター	 */	void laplacian98Filter() {		int[][] filter = 		{{0,0,0,1,1,1,0,0,0},		 {0,0,0,1,1,1,0,0,0},		 {0,0,0,1,1,1,0,0,0},		 {1,1,1,-4,-4,-4,1,1,1},		 {1,1,1,-4,-4,-4,1,1,1},		 {1,1,1,-4,-4,-4,1,1,1},		 {0,0,0,1,1,1,0,0,0},		 {0,0,0,1,1,1,0,0,0},		 {0,0,0,1,1,1,0,0,0}		 };		normalFilter(filter, 9);	}	/**	 * ３×３　４方向　ラプラシアン先鋭化フィルター	 */	void acute34Filter() {		int[][] filter = 		{{0,-1,0},		 {-1,5,-1},		 {0,-1,0}};		normalFilter(filter, 3);	}	/**	 * ３×３　８方向　ラプラシアン先鋭化フィルター	 */	void acute38Filter() {		int[][] filter = 		{{-1,-1,-1},		 {-1,9,-1},		 {-1,-1,-1}};		normalFilter(filter, 3);	}	/**	 * ９×９　８方向　ラプラシアン先鋭化フィルター	 */	void acute98Filter() {		int[][] filter = 		{{0,0,0,-1,-1,-1,0,0,0},		 {0,0,0,-1,-1,-1,0,0,0},		 {0,0,0,-1,-1,-1,0,0,0},		 {-1,-1,-1,4,4,4,-1,-1,-1},		 {-1,-1,-1,4,5,4,-1,-1,-1},		 {-1,-1,-1,4,4,4,-1,-1,-1},		 {0,0,0,-1,-1,-1,0,0,0},		 {0,0,0,-1,-1,-1,0,0,0},		 {0,0,0,-1,-1,-1,0,0,0}		 };		normalFilter(filter, 9);	}		/**	 *  pixels の指定座標の色を通知する。	 * @param x	 * @param y	 * @return	 */	int getInt (int x, int y) {		if (pixels != null) {			return pixels[y][x];		} else {			return 0;		}	}		/**	 *  pixels の指定座標の色 SRGB を通知する。	 * @param x	 * @param y	 * @return	 */	SRGB getSRGB (int x, int y) throws ArrayIndexOutOfBoundsException{		if (pixels != null) {			return new SRGB(pixels[y][x]);		} else {			return new SRGB();		}	}	int getH() {		return h;	}	int getW() {		return w;	}	SRGB getAreaSRGB(int areaNum) {		ColorOBJ color = areaOBJ[areaNum].getColorOBJ();		return color.getFirstSRGB();	}	AreaOBJ getAreaOBJ(int areaNum) {		return areaOBJ[areaNum];	}	ColorOBJ getColorOBJ(int colorNum) {		return colorOBJ[colorNum];	}	int getColorOBJNum() {		return colorOBJNum;	}		int[][] getAreaPixels() {		return areaPixels;	}	double[][] getDistinguishGravity() {		return distinguishGravity;	}	double[][] getContrastGravity() {		return contrastGravity;	}	double[] getKeepGravity() {		return keepGravity;	}	CompoundDesire getCompoundDesire() { return compoundDesire; }	DesiredDistinguishability getDesiredDistinguishability() { return dDesire; }	DesiredContrast getDesiredContrast() { return cDesire; }	DesiredKeepability getDesiredKeepability() { return kDesire; }		Lab[] getOptimizedLab() { return optimizedLab; }	Lab getOptimizedLab(int i) { return optimizedLab[i]; }		/**	 * pixel 画素すべての色を ColoOBJ にする　自動クラスタリング（？）	 *	 */	void autoClustering() {		// pixel から clusterPoints を作成		ClusterBinaryTree tree = new ClusterBinaryTree(pixels[0][0]);		int colorNum = 1;		for (int j=1;j<w;j++) {			if (tree.add(pixels[0][j])) {				colorNum++;			}		}		for (int i=1;i<h;i++) {			for (int j=0;j<w;j++) {				if (tree.add(pixels[i][j])) {					colorNum++;				}			}		}		ClusterPoint[] clusterPoints = new ClusterPoint[colorNum];		tree.sort(clusterPoints, 0);		tree = null;		// 代表色のセット		int[] colorIntArray = new int[colorNum];		for (int i=0;i<colorNum;i++) {			colorIntArray[i] = clusterPoints[i].getSRGBInt();		}		kClustering(colorNum, colorIntArray, -1);					}	/**	 * k クラスタリング法。	 * colorOBJ を初期化する。	 * @param k	 * @param representColor サイズが k の代表色。int 配列。	 * @param clusteringNum クラスタリングのループ回数	 */	void kClustering(int k, int[] representColor, int clusteringNum) {				// pixel から clusterPoints を作成		ClusterBinaryTree tree = new ClusterBinaryTree(pixels[0][0]);		int colorNum = 1;		for (int j=1;j<w;j++) {			if (tree.add(pixels[0][j])) {				colorNum++;			}		}		for (int i=1;i<h;i++) {			for (int j=0;j<w;j++) {				if (tree.add(pixels[i][j])) {					colorNum++;				}			}		}		ClusterPoint[] clusterPoints = new ClusterPoint[colorNum];		tree.sort(clusterPoints, 0);				int len = clusterPoints.length;		System.out.println("histogram.length: " + len);		/* デバッグ		for (int i=0;i<colorNum;i++) {			System.out.println("i: " + clusterPoints[i].getSRGBInt() + new SRGB(clusterPoints[i].getSRGBInt()));		}*/				// representColor から reprPoints を作成		ClusterReprPoint[] reprPoints = new ClusterReprPoint[k];		SRGB tempSRGB = new SRGB();		// XYZ tempXYZ = new XYZ();		// double[] tempDoubles = new double[3];		for (int i=0;i<k;i++) {			tempSRGB.setInt(representColor[i]);			Luv1976 newLuv = new Luv1976();			tempSRGB.getLuv1976(newLuv);			reprPoints[i] = new ClusterReprPoint(i, newLuv);		}				// すべての色について、最も近い代表色を決定する。		double minRange = Double.MAX_VALUE;		double range = 0.0;		int reprInt = -1;		boolean reprChange;		int loopNum = 0;		// 代表色決定のループ		while(true) {			reprChange = false;			// それぞれの色からもっとも距離が近い代表色を見つける。			for (int i=0;i<len;i++) {				minRange = Double.MAX_VALUE;				for (int j=0;j<k;j++) {					range = clusterPoints[i].getDistance(reprPoints[j]);					if (range < minRange) {						reprInt = j;						minRange = range;					}				}				clusterPoints[i].setRepr(reprPoints[reprInt]);				reprPoints[reprInt].addPoint(clusterPoints[i]);				if (!reprChange && 				(clusterPoints[i].getRepr() != clusterPoints[i].getOldRepr())) {					reprChange = true;					System.out.println("repr changed at clusterPoints["+i+"]");				}			}			// n 回のループで終了			if (loopNum > clusteringNum) {				System.out.println("loop: "+loopNum);				break;			}			// 代表色が変化していなければ終了			if(!reprChange) {				break;			}			// 新しい代表色を重心から求める。			for (int i=0;i<k;i++) {				reprPoints[i].changeCenterGravity();				reprPoints[i].clearPoints();			}			loopNum++;		}		// 代表色が決定したら、重心の SRGB 値を求めておく。		// また colorOBJ を初期化する。		colorOBJNum = k;		colorOBJ = new ColorOBJ[colorOBJNum];		for (int i=0;i<k;i++) {			reprPoints[i].centerLuv.getSRGB(tempSRGB);			reprPoints[i].centerGravity = tempSRGB.getInt();			colorOBJ[i] = new ColorOBJ(i);			colorOBJ[i].setFirstSRGB(reprPoints[i].centerGravity);		}		// 色の object に代表色をいれておく。		for (int i=0;i<len;i++) {			clusterPoints[i].setReprInt(clusterPoints[i].getRepr().centerGravity);		}		// colorOBJIdMatrix を初期化		if (colorOBJIdMatrix == null) colorOBJIdMatrix = new int[h][w];		// colorReducePixels に色を代表色に変換した画像をいれる。		if (colorReducePixels == null) colorReducePixels = new int[h][w];		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				ClusterPoint tempClusterPoint = tree.getClusterPoint(pixels[i][j]);				colorReducePixels[i][j] = tempClusterPoint.getReprInt();				colorOBJIdMatrix[i][j] = tempClusterPoint.getRepr().getId();			}		}		colorUnificationBoolean = true;		setRepresentFirst();		// 重要度係数の初期化		distinguishGravity = new double[colorOBJNum][colorOBJNum];		contrastGravity = new double[colorOBJNum][colorOBJNum];		keepGravity = new double[colorOBJNum];	}			/**	 * Pixelの列と所属色から領域を決定、面積や距離も測る。	 * areaOBJ を初期化設定し、colorOBJ と関連付ける。	 * @param reprK K色	 * @param allowNum 隣りだと思う距離（標準は１）	 */	public void autoDecidingAreas(int reprK, int allowNum){		areaPixels = new int[h][w];		int areaNextNum = 0;				//area番号を定めたかどうか		boolean areaCreatedBoolean = false;		int ii, jj;				// areaPixels[h][w] の番号振り		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				ii = i - allowNum;				areaCreatedBoolean = false;				for (;ii<i;ii++) {					jj = j - allowNum;					for (;jj<j+allowNum+1;jj++) {						if (ii>-1 && jj>-1 && jj<w) {							if (pixels[i][j]==pixels[ii][jj]) {								if (areaCreatedBoolean) {									if (areaPixels[i][j] < areaPixels[ii][jj]) {										changeAreaPixels(areaPixels[ii][jj], areaPixels[i][j], i, areaNextNum);										areaNextNum--;									} else if (areaPixels[i][j] > areaPixels[ii][jj]) {										changeAreaPixels(areaPixels[i][j], areaPixels[ii][jj], i, areaNextNum);										areaNextNum--;									}								} else {									areaPixels[i][j] = areaPixels[ii][jj];									areaCreatedBoolean = true;								}							}						}					}				}				ii = i;				for (jj=j-allowNum;jj<j;jj++) {					if (jj>-1 && pixels[i][j]==pixels[ii][jj]) {						if (areaCreatedBoolean) {							if (areaPixels[i][j] < areaPixels[ii][jj]) {								changeAreaPixels(areaPixels[ii][jj], areaPixels[i][j], i, areaNextNum);								areaNextNum--;							} else if (areaPixels[i][j] > areaPixels[ii][jj]) {								changeAreaPixels(areaPixels[i][j], areaPixels[ii][jj], i, areaNextNum);								areaNextNum--;							}						} else {							areaPixels[i][j] = areaPixels[ii][jj];							areaCreatedBoolean = true;						}					}				}				if (!areaCreatedBoolean) {					areaPixels[i][j] = areaNextNum++;				}			}		}		//領域配列、色配列の初期化		areaOBJNum = areaNextNum;		areaOBJ = new AreaOBJ[areaOBJNum];		for (int i=0;i<areaOBJNum;i++) {			areaOBJ[i] = new AreaOBJ(i);		}		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].prepareAddAreaV();		}		/* デバッグ　領域番号確認		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				System.out.print(areaPixels[i][j]+",");			}			System.out.print("\n");		}		*/				// AreaOBJ の面積や隣り合いを設定		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				// この Pixel の入力から重心を変更、面積を 1 増加				areaOBJ[areaPixels[i][j]].pixelAdd(i,j);				// 対応する色 Object を探す。				if (areaOBJ[areaPixels[i][j]].getColorOBJ()==null) {					for (int col=0;col<colorOBJNum;col++) {						if (pixels[i][j]==colorOBJ[col].getFirstSRGB().getInt()) {							areaOBJ[areaPixels[i][j]].setColorOBJ(colorOBJ[col]);							colorOBJ[col].addAreaV(areaOBJ[areaPixels[i][j]]);						}					}				}				//隣りあう AreaOBJ を登録する(どちら側にも登録する。)				for (ii=i-allowNum;ii<i;ii++) {					for (jj=j-allowNum;jj<j+allowNum+1;jj++) {						if (ii>-1 && jj>-1 && jj<w) {							if (areaPixels[i][j]!=areaPixels[ii][jj]) {								areaOBJ[areaPixels[i][j]].setNeighbor(areaOBJ[areaPixels[ii][jj]]);								areaOBJ[areaPixels[ii][jj]].setNeighbor(areaOBJ[areaPixels[i][j]]);							}						}					}				}				ii=i;				for (jj=j-allowNum;jj<j;jj++) {					if (jj>-1 && areaPixels[i][j]!=areaPixels[ii][jj]) {						areaOBJ[areaPixels[i][j]].setNeighbor(areaOBJ[areaPixels[ii][jj]]);						areaOBJ[areaPixels[ii][jj]].setNeighbor(areaOBJ[areaPixels[i][j]]);					}				}			}		}		// colorOBJ との関連づけ		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].endAddAreaV();		}		/* デバッグ　領域サイズと重心と隣接の確認		for (int i=0;i<areaOBJNum;i++) {			System.out.println("area["+i+"] ="+areaOBJ[i].getArea()+" ("+areaOBJ[i].getCenterX()+", "+areaOBJ[i].getCenterY()+")");			System.out.println("neighbor: "+areaOBJ[i].getNeighborData());		}		*/				// AreaOBJ の分散を求め、記憶させる。		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) {				areaOBJ[areaPixels[i][j]].calcuDisperse(i,j);			}		}		for (int i=0;i<areaOBJNum;i++) {			areaOBJ[i].endCalcuDisperse();			//System.out.println("area["+i+"].disperse ="+areaOBJ[i].getDisperse());		}		setRepresentFirst();		// 重要度係数の初期化		distinguishGravity = new double[colorOBJNum][colorOBJNum];		contrastGravity = new double[colorOBJNum][colorOBJNum];		keepGravity = new double[colorOBJNum];		// pixel と領域と色の関係が定まった。		colorUnificationBoolean = true;	}		// 識別性の自動設定	void autoSetDistinguishGravity() {		for (int i=0;i<colorOBJNum;i++) {			int areaNum = colorOBJ[i].getAreaNum();			for (int j=0;j<areaNum;j++) {				Iterator it = colorOBJ[i].getAreas()[j].getNeighborsV().iterator();				Iterator itL = colorOBJ[i].getAreas()[j].getNeighborLevelV().iterator();				while(it.hasNext()) {					int temp = ((AreaOBJ)(it.next())).getColorOBJ().num;					double tempL = (double)((Integer)(itL.next())).intValue();					distinguishGravity[i][temp] += tempL;					//System.out.println("Dis["+i+"]["+temp+"]: "+tempL);				}			}			/*			for (int j=0;j<colorOBJNum;j++) {				System.out.println("DistinguishGravity ["+i+"]["+j+"] = "+distinguishGravity[i][j]);			}*/		}	}		/**	 * fromNum を toNum に統一し、最終番号 areaNextNum を fromNum に変更する。	 * 呼び出し元は、areaNextNum--; をすること。	 * @param fromNum	 * @param toNum	 * @param endI	 * @param areaNextNum	 */	private void changeAreaPixels(int fromNum, int toNum, int endI, int areaNextNum) {		for (int i=0;i<endI+1;i++) {			for (int j=0;j<w;j++) {//右端まで見てしまうが問題ない				if (areaPixels[i][j] == fromNum) {					areaPixels[i][j] = toNum;				}				if (areaPixels[i][j] == areaNextNum-1) {					areaPixels[i][j] = fromNum;				}			}		}	}		/**	 * 領域を統合したり新たに作ったり	 */	public void manualDecidingAreas(){	}		/**	 * 色盲シミュレーション	 * 何種かの色に統一していなければpixelsを色盲変換。	 * 統一していれば色OBJに対して色盲変換。	 */	public void dichromatConvertion(int dichromatType){		SRGB srgb = new SRGB();		// XYZ xyz = new XYZ();		// RGB rgb = new RGB();		LMS lms = new LMS();		LMS dichromatLMS = new LMS();		// double[] values = new double[3];		//代表色の決定をしていた場合		if (colorUnificationBoolean) {			/*オリジナルを色盲変換してなければ色盲変換する。			if (colorOBJ[0].getFirstDichromatSRGB(dichromatType) == null) {				for (int i=0;i<colorOBJNum;i++) {					srgb = colorOBJ[i].getFirstSRGB();					srgb.getLMS(xyz, rgb, lms, values);					Dichromat.convert(lms, dichromatLMS, dichromatType);					colorOBJ[i].setFirstDichromatSRGB(dichromatLMS.getSRGB(), dichromatType);				}			}						//再配色をしていれば色盲変換する。			if (colorOBJ[0].getOptimizedSRGB() != null){				for (int i=0;i<colorOBJNum;i++) {					srgb = colorOBJ[i].getOptimizedSRGB();					srgb.getLMS(xyz, rgb, lms, values);					Dichromat.convert(lms, dichromatLMS, dichromatType);									colorOBJ[i].setOptimizedDichromatSRGB(dichromatLMS.getSRGB(), dichromatType);				}			}			*/		//pixelの色データしかない場合		} else if (pixels != null){			if (filteredPixels == null) {				filteredPixels = new int[h][w];			}			for (int i=0;i<h;i++) {				for (int j=0;j<w;j++) {					srgb.setInt(pixels[i][j]);					srgb.getLMS(lms);					Dichromat.convert(lms, dichromatLMS, dichromatType);					filteredPixels[i][j] = dichromatLMS.getSRGB().getInt();				}			}		}	}		/**	 * 願望関数の係数を操作する	 */	void setDistinguishGravity(int areaNumI, int areaNumJ, double gravity){		distinguishGravity[areaNumI][areaNumJ] = gravity;		distinguishGravity[areaNumJ][areaNumI] = gravity;	}	void setContrastGravity(int colorNumI, int colorNumJ, double gravity) {		contrastGravity[colorNumI][colorNumJ] = gravity;		contrastGravity[colorNumJ][colorNumI] = gravity;	}	void setKeepGravity(int colorNum, double gravity) {		keepGravity[colorNum] = gravity;	}		/**	 * 実験IDを使った正常者用のSA	 * @param t0　初期温度	 * @param tStay　一定温度での探索回数	 * @param tExit　終了温度	 * @param tCold　温度冷却倍率	 * @param jump0　初期ジャンプ距離	 * @param jumpStay　ジャンプを冷却するときのジャンプ失敗回数(×tStay回）	 * @param jumpCold　ジャンプ冷却倍率	 * @return	 */	int trichromatSA(double t0, int tStay, double tExit, double tCold,			double jump0, int jumpStay, double jumpCold) {				MinimizeExperiment exp = makeExperiment(Dichromat.TRICHROMAT);		long start = System.currentTimeMillis();		exp.tirichromatSA(t0, tStay, tExit, tCold, jump0, jumpStay, jumpCold);		long stop = System.currentTimeMillis();		System.out.println("Trichromat Simulated Annealing : Time="+(stop-start));				// 色のセット		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setOptimizedLab(exp.dlmss[i].getLab());		}				return expNumMax-1;	}		/**	 * 実験IDを使ったSA	 * @param type	 * @return	 */	int sa(int type) {		MinimizeExperiment exp = makeExperiment(type);		long start = System.currentTimeMillis();		exp.simulatedAnnealing();		long stop = System.currentTimeMillis();		System.out.println("Simulated Annealing : Time="+(stop-start));		return expNumMax-1;	}			/**	 * SimulatedAnnealing	 */	void simulatedAnnealing(int dType){				double[] tempKeepGravity = new double[colorOBJNum];		// 願望の生成		Lab[] conIdealLabs = new Lab[colorOBJNum];		Lab[] keepIdealLabs = new Lab[colorOBJNum];		// 願望の理想値セット		for (int i=0;i<colorOBJNum;i++) {			conIdealLabs[i] = colorOBJ[i].getFirstLab().copyLab();			keepIdealLabs[i] = colorOBJ[i].getFirstDichromatSRGB(dType).getLab();		}				// 色の保存をする場合の色重要性除去		boolean[] fixColoring = new boolean[colorOBJNum];		if (fixNaturalColoring) {			for (int i=0;i<keepGravity.length;i++) {				if (keepGravity[i] < fixNaturalColoringBorder) {					fixColoring[i] = false;					tempKeepGravity[i] = keepGravity[i];				}				else {					fixColoring[i] = true;					tempKeepGravity[i] = 0.0;				}			}		} else {			for (int i=0;i<keepGravity.length;i++) {				fixColoring[i] = false;				tempKeepGravity[i] = keepGravity[i];			}		}				// 願望の完成		CompoundDesire compoundDesire = new CompoundDesire(colorOBJNum);		DesiredDistinguishability dd = new DesiredDistinguishability(distinguishGravity, dType);		DesiredContrast dc = new DesiredContrast(conIdealLabs, contrastGravity, dType);		DesiredKeepability dk = new DesiredKeepability(keepIdealLabs, tempKeepGravity, dType);		Desire tempDesire[] = {dd, dc, dk};		compoundDesire.add(tempDesire);				// Simulated Annealing の実行		sa = new SimulatedAnnealing(compoundDesire, keepIdealLabs, fixColoring, dType);		sa.solve();		System.out.println("End Energy: "+sa.energy());				// 色のセット		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setOptimizedLab(sa.nowLabs[i]);		}	}		//----------------------------------------------------------------------------------------------		/************************************************************	 *						最小化実験関連						*	 ************************************************************/		/**	 * 最小化問題の作成メソッド	 * @param type	 * @return	 */	public MinimizeExperiment makeExperiment(int type) {				// 願望の理想状態を作成		Lab[] conIdealLabs = new Lab[colorOBJNum];		Lab[] keepIdealLabs = new Lab[colorOBJNum];		for (int i=0;i<colorOBJNum;i++) {			conIdealLabs[i] = colorOBJ[i].getFirstLab().copyLab();			keepIdealLabs[i] = colorOBJ[i].getFirstDichromatSRGB(type).getLab();		}				// 色の保存をする場合の色重要性除去		double[] tempKeepGravity = new double[colorOBJNum];		boolean[] fixColoring = new boolean[colorOBJNum];		if (fixNaturalColoring) {			for (int i=0;i<keepGravity.length;i++) {				if (keepGravity[i] < fixNaturalColoringBorder) {					fixColoring[i] = false;					tempKeepGravity[i] = keepGravity[i];				} else {					fixColoring[i] = true;					tempKeepGravity[i] = 0.0;				}			}		} else {			for (int i=0;i<keepGravity.length;i++) {				fixColoring[i] = false;				tempKeepGravity[i] = keepGravity[i];			}		}				//重要度がすべて０ならば願望を作成しないようフラグを立てる。		boolean dGravityExist = false, cGravityExist = false, kGravityExist = false;		for(int i=0;i<colorOBJNum;i++) {			for (int j=0;j<colorOBJNum;j++) {				if (distinguishGravity[i][j]>0) {					dGravityExist = true;					break;				}			}		}		for(int i=0;i<colorOBJNum;i++) {			for (int j=0;j<colorOBJNum;j++) {				if (contrastGravity[i][j]>0) {					cGravityExist = true;					break;				}			}		}		for (int i=0;i<colorOBJNum;i++) {			if (keepGravity[i] > 0){				kGravityExist = true;				break;			}		}		// 願望の作成		CompoundDesire compoundDesire = new CompoundDesire(colorOBJNum);		if (dGravityExist) {			DesiredDistinguishability dDesire = new DesiredDistinguishability(distinguishGravity, type);			compoundDesire.add(dDesire);		}		if (cGravityExist) {			DesiredContrast cDesire = new DesiredContrast(conIdealLabs, contrastGravity, type);			compoundDesire.add(cDesire);		}		if (kGravityExist) {			DesiredKeepability kDesire = new DesiredKeepability(keepIdealLabs, keepGravity, type);			compoundDesire.add(kDesire);		}				// 初期色のオブジェクト作成		LMS[] dlmss = new LMS[colorOBJNum];				// 初期色の入力		for (int i=0;i<colorOBJNum;i++) {			//各初期色をdlmssに入力。			dlmss[i] = new LMS();			colorOBJ[i].getFirstSRGB().getLMS(dlmss[i]);			Dichromat.boundaryInConvertNewtonLMS(dlmss[i], type);			//TODO dlmssに入力した値は、本当の色盲変換で作った色ではないため、一般的な色でない。			//このdlmssは、これからの最適化の初期値に使われる。			//よって、初期値固定を行った場合、本当の初期値とのずれが起こり、不満エネルギーが発生する。		}				//実験状態の作成		MinimizeExperiment exp = new MinimizeExperiment(dlmss, compoundDesire, fixColoring, type);		expVector.addElement(exp);		expNumMax++;		return exp;	}		/**	 * GUIから ID = expNum の実験状態に対して、ニュートン法を実行するメソッド	 * TODO どの程度ニュートン法を行うのか、どのように行うのか、メソッドごとに整理したい。	 * @param expNum	 */	public void roundNewtonExperiment(int expNum ) {		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		exp.roundNewton();	}		/**	 * GUIから ID = expNum の実験状態に対して、Simulated Annealing 法を実行するメソッド	 * TODO 実行の程度を表すパラメーターなどが必要かも。	 * @param expNum	 */	public void saExperiment(int expNum) {		// MinimizeExperiment exp = expVector.get(expNum);		expVector.get(expNum);	}		/**	 * 実験 ID=expNum で最適化された色をsrgbにセット	 * 結果の表示に用いる。	 * @param expNum	 * @param srgb	 */	public void setOptimizedColor(int expNum, SRGB[] srgb) {		assert srgb.length==colorOBJNum;		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		for(int i=0;i<colorOBJNum;i++) {			exp.dlmss[i].getSRGB(srgb[i]);		}	}			/************************************************************	 *						ニュートン法						*	 ************************************************************/		/**	 * NewtonRaphson	 * @param dType	 */	public int newtonRaphson(int dType){		// 最小化実験オブジェクトを作成してIDを返す。		MinimizeExperiment exp = makeExperiment(dType);		// ニュートン法を行う。		long start = System.currentTimeMillis();		exp.roundNewton();		long stop = System.currentTimeMillis();		System.out.println("Round Newton : Time="+(stop-start));		return expNumMax-1;	}		/**	 * SA and Newton	 * @param dType	 * @return	 */	public int[] roughSAandNewton(int dType) {		long start = System.currentTimeMillis();		MinimizeExperiment exp = makeExperiment(dType);		//SAとニュートン		MinimizeExperiment[] exps = exp.roughSAandNewton();		//保存		int[] expNum = new int[exps.length];		expNum[0] = expNumMax-1;		for(int i=1;i<exps.length;i++) {			expVector.addElement(exps[i]);			expNum[i] = expNumMax++;		}		long stop = System.currentTimeMillis();		System.out.println("roughSA and Newton : Time="+(stop-start));		return expNum;	}		public double getEnergy(int expNum, double[][] cont, double[][] dist, double[] keep) {		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		return exp.getEnergy(cont, dist, keep);	}		/**	 * 現在のニュートン法のエネルギー状態を文字列で得る。	 * 実験状態ID=expID のdlmssとcompDesireによって値は変わる。	 * @param expNum	 * @param cont	 * @param dist	 * @param keep	 * @param penalty	 * @param line	 * @return	 */	public String getNewtonEnergy(int expNum, String[][] cont, String[][] dist,			String[] keep, String[] penalty, String[] line) {		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		return exp.getNewtonEnergy(cont, dist, keep, penalty, line);	}	/**	 * コントラストの理想値もGUIから見られるようにメソッド提供。	 * @param expNum	 * @param c_i	 * @param c_j	 * @return	 */	public double getContIdeal(int expNum, int c_i, int c_j) {		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		return exp.expCompoundDesire.getContrastIdeal(c_i,c_j);	}		/*	 * 色の設定メソッド	 */		/**	 * 指定した番号の実験を呼ぶ内部メソッド。	 * 複数の実験状態の中から一つを選び、その最適色をColorOBJにセットする。	 * @param expNum	 */	private void setExperimentOptimizedColor(int expNum) {		if(expNum==activeExpNum) return;//この実験状態は、既にColorOBJにセットされているので終了。		MinimizeExperiment exp = (MinimizeExperiment)(expVector.get(expNum));		for(int i=0;i<colorOBJNum;i++) {			exp.dlmss[i].getSRGB(tempSRGB);			colorOBJ[i].setOptimizedSRGB(tempSRGB);		}		activeExpNum = expNum;//ColorOBJにセットされている実験状態を記録。	}	/**	 * GUI側から呼び出して、ある実験番号の最適色をもらうためのメソッド。	 * 実験ID=expNum の最適色をreturnSRGBsにセットする。	 * @param expNum	 * @param returnSRGBs	 */	public void getOptimizedSRGB (int expNum, SRGB[] returnSRGBs) {		assert returnSRGBs.length==colorOBJNum;		setExperimentOptimizedColor(expNum);		for(int i=0;i<colorOBJNum;i++) {			colorOBJ[i].getOptimizedSRGB(returnSRGBs[i]);		}	}	/**	 * GUI側から呼び出して、ある実験番号の最適色盲色をもらうためのメソッド。	 * 実験ID=expNum の最適色の色盲の色をreturnSRGBsにセットする。	 * @param expNum	 * @param returnSRGBs	 * @param type 見たい色盲タイプ（最適化された色盲タイプではない）	 */	public void getOptimizedDichromatSRGB (int expNum, SRGB[] returnSRGBs, int type) {		assert returnSRGBs.length==colorOBJNum;		setExperimentOptimizedColor(expNum);		switch(type) {		case Dichromat.PROTANOPE:			for(int i=0;i<colorOBJNum;i++) colorOBJ[i].getOptimizedProtanopeSRGB(returnSRGBs[i]);		break;		case Dichromat.DEUTERANOPE:			for(int i=0;i<colorOBJNum;i++) colorOBJ[i].getOptimizedDeuteranopeSRGB(returnSRGBs[i]);		break;		case Dichromat.TRITANOPE:			for(int i=0;i<colorOBJNum;i++) colorOBJ[i].getOptimizedTritanopeSRGB(returnSRGBs[i]);		break;		case Dichromat.TRICHROMAT:			for(int i=0;i<colorOBJNum;i++) colorOBJ[i].getOptimizedSRGB(returnSRGBs[i]);		}	}		/************************************************************	 *					表示関連。書き直し？					*	 ************************************************************/		/**	 * canvas表示色をオリジナルの色に設定する。	 */	void setRepresentFirst() {		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setRepresentFirst();		}	}	/**	 * canvas表示色をオリジナルの色盲の色に設定する。	 * @param dichromatType	 */	void setRepresentFirstDichromat(int dichromatType) {		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setRepresentFirstDichromat(dichromatType);		}	}	/**	 * canvas表示色を再配色後の色に設定する。	 */	void setRepresentOptimized() {		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setRepresentOptimized();		}	}	/**	 * canvas表示色を再配色後の色盲の色に設定する。	 * @param dichromatType	 */	void setRepresentOptimizedDichromat(int dichromatType) {		for (int i=0;i<colorOBJNum;i++) {			colorOBJ[i].setRepresentOptimizedDichromat(dichromatType);		}	}	/**	 * メインに扱う pixels を original に設定する。	 */	void setOriginalPixels() {		pixels = originalPixels;	}	/**	 * メインに扱う pixels を median に設定する。	 */	void setMedianPixels() {		pixels = medianPixels;	}	/**	 * メインに扱う pixels を filtered に設定する。	 */	void setFilteredPixels() {		pixels = filteredPixels;	}	/**	 * メインに扱う pixels を colorReducePixels に設定する。	 */	void setReducePixels() {		pixels = colorReducePixels;	}	/**	 * 画像を Canvas ウィンドウに表示	 */	void drawCanvas(BitmapCanvas canvas) {		int[] thisPixels = new int[h*w];		drawCanvasChild(thisPixels);		canvas.setImage(w,h,thisPixels);		canvas.repaint();	}	/**	 * 実験状態ID=expNumの最適色(optSrgbに代入される)で画像を作る。	 * @param expNum	 * @param optSrgb 最適色をセットして返す	 * @return	 */	BitmapCanvas getOptCanvas(int expNum, SRGB[] optSrgb) {//TODO 既にoptが求まったと仮定。仮定不成立時の振る舞いを書くべし		BitmapCanvas canvas = new BitmapCanvas();		getOptCanvas(expNum, optSrgb, canvas);		return canvas;	}	/**	 * 実験状態ID=expNumの最適色(optSrgbに代入される)で画像を作る。	 * @param expNum	 * @param optSrgb 最適色をセットして返す	 * @param canvas	 */	void getOptCanvas(int expNum, SRGB[] optSrgb, BitmapCanvas canvas) {		int[] thisPixels = new int[h*w];		getOptimizedSRGB(expNum, optSrgb);		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) thisPixels[i*w+j] = optSrgb[colorOBJIdMatrix[i][j]].getInt();		}		canvas.setImage(w,h,thisPixels);	}	/**	 * 実験状態ID=expNumの最適色の色盲画像を作る。	 * @param expNum	 * @param optDichroSrgb 最適色盲色をセットして返す	 * @param type	 * @return	 */	BitmapCanvas getOptDichroCanvas(int expNum, SRGB[] optDichroSrgb, int type) {		BitmapCanvas canvas = new BitmapCanvas();		getOptDichroCanvas(expNum, optDichroSrgb, type, canvas);		return canvas;	}	/**	 * 実験状態ID=expNumの最適色の色盲画像を作る。	 * @param expNum	 * @param optDichroSrgb	 * @param type	 * @param canvas	 */	void getOptDichroCanvas(int expNum, SRGB[] optDichroSrgb, int type, BitmapCanvas canvas) {		int[] thisPixels = new int[h*w];		getOptimizedDichromatSRGB(expNum, optDichroSrgb, type);		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) thisPixels[i*w+j] = optDichroSrgb[colorOBJIdMatrix[i][j]].getInt();		}		canvas.setImage(w,h,thisPixels);	}	/**	 * 画像を新しいウィンドウに表示	 * @param title	 */	void drawCanvas(String title) {		int[] thisPixels = new int[h*w];		drawCanvasChild(thisPixels);		JFrame frame = new JFrame(title);		frame.getContentPane().setLayout(new BorderLayout());		BitmapCanvas newCanvas = new BitmapCanvas();		newCanvas.setImage(w,h,thisPixels);		frame.getContentPane().add(newCanvas, BorderLayout.CENTER);		frame.setSize(w+10, h+30);		frame.addWindowListener(new WindowCloseListener(frame));		frame.setVisible(true);	}	/**	 * ボタンとラベル付の画像を新しいウィンドウに表示	 * @param title	 * @param b	 * @param label	 * @param superLabel	 */	void drawCanvas(String title, Button[] b, Label[] label, Label[] superLabel) {		assert b.length == label.length;		int[] thisPixels = new int[h*w];		drawCanvasChild(thisPixels);		JFrame frame = new JFrame(title);		Panel ePanel = new Panel();		BitmapCanvas newCanvas = new BitmapCanvas();		newCanvas.setImage(w,h,thisPixels);		frame.getContentPane().setLayout(new BorderLayout());		ePanel.setLayout(new GridLayout(b.length+1, 2));		for (int i=0;i<b.length;i++) {			ePanel.add(b[i]);			ePanel.add(label[i]);		}		ePanel.add(superLabel[0]);		ePanel.add(superLabel[1]);		frame.getContentPane().add(newCanvas, BorderLayout.CENTER);		frame.getContentPane().add(ePanel, BorderLayout.EAST);		frame.setSize(w+250, h+30);		frame.addWindowListener(new WindowCloseListener(frame));		frame.setVisible(true);	}	/**	 * 画像内容を thisPixels にセットする	 * @param thisPixels	 */	private void drawCanvasChild(int[] thisPixels) {		if (colorUnificationBoolean) {			for (int i=0;i<h;i++) {				for (int j=0;j<w;j++) {					//ColorOBJ col = areaOBJ[areaPixels[i][j]].getColorOBJ();					SRGB srgb = colorOBJ[colorOBJIdMatrix[i][j]].getRepresentSRGB();					thisPixels[i*w+j] = srgb.getInt();				}			}		} else {			for (int i=0;i<h;i++) {				for (int j=0;j<w;j++) {					thisPixels[i*w+j] = pixels[i][j];				}			}		}	}	/**	 * 色盲変換の色をキャンバスに描画	 * @param dType	 * @param canvas	 */	public void getDichroCanvas(int dType, BitmapCanvas canvas) {		int[] thisPixels = new int[h*w];		int[] dichroInt = new int[colorOBJNum];		for(int i=0;i<colorOBJNum;i++) {			dichroInt[i] = colorOBJ[i].getFirstDichromatSRGB(dType).getInt();		}		for (int i=0;i<h;i++) {			for (int j=0;j<w;j++) thisPixels[i*w+j] = dichroInt[colorOBJIdMatrix[i][j]];		}		canvas.setImage(w,h,thisPixels);	}/*	*//**	 * draw Dichromat-conversion image on BitmapCanvas	 * @param type : Dichromat Type	 * @param canvas : draw on canvas	 *//*	public void drawDichromat(int type, BitmapCanvas canvas) {		dichromatConvertion(type);		if (colorUnificationBoolean) {			setRepresentFirstDichromat(type);		} else{			setFilteredPixels();		}		drawCanvas(canvas);	}*//*	*//**	 * draw Dichromat-conversion of Repaint image on BitmapCanvas	 * @param type	 * @param canvas	 *//*	public void drawRepaintDichromat(int type, BitmapCanvas canvas) {		setRepresentFirst();		simulatedAnnealing(type);		setRepresentOptimizedDichromat(type);		drawCanvas(canvas);	}*/	/**	 * draw each Dichromat-conversion of Repaint image on each Bitmapcanvas	 * @param type : Repaint for this type	 * @param canvas  : the Repaint image viewed by Tritanope	 * @param canvasP : the Repaint image viewed by Protanope	 * @param canvasD : the Repaint image viewed by Deuteranope	 * @param canvasT : the Repaint image viewed by Tritanope	 *//*	public void drawRepaintDichromat(int type, BitmapCanvas canvas, 			BitmapCanvas canvasP, BitmapCanvas canvasD, BitmapCanvas canvasT) {		setRepresentFirst();		simulatedAnnealing(type);		setRepresentOptimized();		drawCanvas(canvas);		setRepresentOptimizedDichromat(Dichromat.PROTANOPE);		drawCanvas(canvasP);		setRepresentOptimizedDichromat(Dichromat.DEUTERANOPE);		drawCanvas(canvasD);		setRepresentOptimizedDichromat(Dichromat.TRITANOPE);		drawCanvas(canvasT);	}*//*	*//**	 * draw Repaint image on Bitmapcanvas c1, and	 * draw Dichromat-conversion of Repaint image on BitmapCanvas c2	 * @param type	 * @param c1	 * @param c2	 *//*	public void drawRepaintAndRepaintDichromat(int type, BitmapCanvas c1, BitmapCanvas c2) {		//Repaint viewed by Tritanope		setRepresentFirst();		simulatedAnnealing(type);		setRepresentOptimized();		drawCanvas(c1);		// Repaint viewed by Dichromat		setRepresentOptimizedDichromat(type);		drawCanvas(c2);	}*/	/**	 * フレームを閉じたときのイベント	 */	class WindowCloseListener extends WindowAdapter{		private Frame frame;		WindowCloseListener(Frame frame){			this.frame = frame;		}		public void windowClosing(WindowEvent e){			frame.setVisible(false);		}	}}