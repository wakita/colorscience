/* * 作成日： 2005/12/11 * */package jp.ac.titech.is.wakitalab.color.shimamura;/** * 色と願望とそのエネルギーを持ち、一つの最適解の探索実験を管理する。 * 主に、Newton や SimultedAnnealing のスケジューリングを行う。 * @author shinamu1 * */public class MinimizeExperiment implements java.io.Serializable{	// TODO 外から願望の操作をしたい。理想値の設定や願望係数の設定など。	int type;	int n;	/**	 * 最適化するvの優先順位を保存する配列。	 */	CompoundDesire expCompoundDesire;	LMS[] dlmss;	Lab[] tempLab;	boolean[] fixColoring;	private int[] priorityNum;	private double newtonEnergy = 0 /*, energy = 0 */;	private double[][] contNewtonTable, distNewtonTable;	private double[] 	keepNewtonTable, penaltyTable, lineNewtonTable;	private Newton newton;	private SimulatedAnnealing sa;		static final long serialVersionUID = "MinimizeExperiment".hashCode();	/**	 * 願望関数の初期化など	 * @param dlmss オブジェクト渡し	 * @param compDesire オブジェクト渡し	 * @param fixColoring オブジェクト渡し	 * @param type	 */	MinimizeExperiment(LMS[] dlmss, CompoundDesire compDesire, boolean[] fixColoring, int type) {		this.dlmss = dlmss;		this.expCompoundDesire = compDesire;		this.type = type;		n = dlmss.length;		this.fixColoring = fixColoring;		priorityNum = new int[n];		contNewtonTable = new double[n][n];		distNewtonTable = new double[n][n];		keepNewtonTable = new double[n];		penaltyTable = new double[n];		lineNewtonTable = new double[n];		// newton メソッド内でエネルギーテーブルは勝手に書き換えてくれる。		newton = new Newton(compDesire, contNewtonTable, distNewtonTable,				keepNewtonTable, penaltyTable, lineNewtonTable, type);		sa = new SimulatedAnnealing(compDesire, dlmss, fixColoring, type);		tempLab = new Lab[n];		for(int i=0;i<n;i++) tempLab[i] = new Lab();	}			/**	 * 何周か色を変化させ、変化が一定に収まったら終了する。	 */	void roundNewton() {		double energyLineTotal = 0;//energyLineTableの合計値。仮の総エネルギー		System.out.println("round Start: energy ="+getEnergy());		long roundNewtonStart = System.currentTimeMillis();		/*		 * ニュートン法を行う色を、優先順位にバブルソート		 */		//それぞれの色に関する、エネルギーを計算		for(int i=0;i<n;i++) {			energyLineTotal += lineNewtonTable[i] =				expCompoundDesire.energyNewton				(i, dlmss, contNewtonTable, distNewtonTable, keepNewtonTable, penaltyTable, type);			priorityNum[i] = i;		}		//energyLineTableの降順に、priorityNumbersをバブルソートで並べる。		for(int i=0;i<n-1;i++) {			for(int j=0;j<n-1-i;j++) {				if(lineNewtonTable[priorityNum[i]]<lineNewtonTable[priorityNum[i+1]]) {					int tmp = priorityNum[i+1];					priorityNum[i+1] = priorityNum[i];					priorityNum[i] = tmp;				}			}		}				//priorityNum順に何度もニュートン法		// double preLineTotal;		// int round = 1;		while(true) {			// preLineTotal = energyLineTotal;			energyLineTotal = 0;			double down = 0;//			System.out.println("\n********** ROUND "+(round++)+" ***********");			for(int i=0;i<n;i++) {				double preLine = lineNewtonTable[priorityNum[i]];				energyLineTotal += (lineNewtonTable[priorityNum[i]] = newton.newton(dlmss, priorityNum[i], 1.0));				down += (preLine - lineNewtonTable[priorityNum[i]]);			}//			System.out.println("energyLineTotal="+energyLineTotal);//ただの目安。ずっと変化しているので正確ではない。			if(down < 10.0) break;		}				//エネルギーをコピー		for (int i=0;i<n;i++) {			lineNewtonTable[i] = expCompoundDesire.energyNewton(i, dlmss,					contNewtonTable, distNewtonTable, keepNewtonTable, penaltyTable, type);		}		long roundNewtonStop = System.currentTimeMillis();				System.out.println("round End : energy ="+getEnergy());		System.out.println("Round Newton : Time="+(roundNewtonStop-roundNewtonStart));		/*		 * sa で本当の極小解に収束		 */		double t0 = 1.0, tCold = 0.9, jump = 0.001, functionEpsilon = 2.0;		int tStay = 10;		// Simulated Annealing の実行		long epSAStart = System.currentTimeMillis();		sa.simulatedAnnealingFunctionEpsilon(dlmss, t0, tStay, tCold, jump, functionEpsilon);		long epSAStop = System.currentTimeMillis();		System.out.println(" epSA time = "+(epSAStop-epSAStart)+"\n");	}		/**	 * SAで大まかに探索し複数のよい点を探し、そこからニュートン法を行う	 */	MinimizeExperiment[] roughSAandNewton () {		//初期化		double t0 = 1000, tCold = 0.95, tExit =160, jump = 10.0, jumpCold = 0.5; 		int bestMax = 1, tStay = 100, jumpStay = 2;		LMS[][] bestLmss = new LMS[bestMax][n];		Lab[][] bestLabs = new Lab[bestMax][n];		double[] bestEnergy = new double[bestMax];		int[] bestSort = new int[bestMax];		for(int i=0;i<n;i++) {			for (int j=0;j<bestMax;j++) {				bestLabs[j][i] = new Lab();				bestLmss[j][i] = new LMS();			}		}		// Simulated Annealing の実行		long saStart = System.currentTimeMillis();		//sa.simulatedAnnealingTemperture(dlmss, bestLmss, bestEnergy, bestSort, t0, tStay, tCold, tExit, jump);		//Lab[] saLab = sa.solve(t0, tStay, tExit, tCold, jump, jumpStay, jumpCold);		sa.solveBest(bestLabs, bestEnergy, bestSort, t0, tStay, tExit, tCold, jump, jumpStay, jumpCold);		long saStop = System.currentTimeMillis();		System.out.println("Rough SA : Time="+(saStop-saStart));				//LMSに書き換えながら境界補正		for(int i=0;i<n;i++) {			for (int j=0;j<bestMax;j++) {				bestLabs[j][i].getLMS(bestLmss[j][i]);				Dichromat.boundaryInConvertNewtonLMS(bestLmss[j][i], type);			}		}				// 複数の実験状態を作成		MinimizeExperiment[] bestExp = new MinimizeExperiment[bestMax];				// ０番目はこのインスタンス自身		bestExp[0] = this;		for(int i=0;i<n;i++) {			dlmss[i].setVector3d(bestLmss[bestSort[0]][i]);		}		roundNewton();		// 実験状態のコピー作成。別の色をセット		for(int i=1;i<bestMax;i++) {			CompoundDesire newExpCompoundDesire = expCompoundDesire.copy();			boolean[] fix = new boolean[n];			for(int j=0;j<n;j++) fix[j] = fixColoring[j];			bestExp[i] = new MinimizeExperiment(bestLmss[bestSort[i]], newExpCompoundDesire, fix, type);			bestExp[i].roundNewton();		}				// 実験状態配列を返す		return bestExp;	}		/**	 * 単純なSAの実行メソッド。	 * 実験パラメーターはSAメソッドのデフォルト値	 */	void simulatedAnnealing() {		sa.solve();		for(int i=0;i<n;i++) {			sa.nowDichroLabs[i].getLMS(dlmss[i]);		}	}		/**	 * 正常者用のSA実行メソッド。	 * 実験結果は色dlmssとgetEnergyメソッドからわかる。	 * @param t0	 * @param tStay	 * @param tExit	 * @param tCold	 * @param jump0	 * @param jumpStay	 * @param jumpCold	 */	void tirichromatSA(double t0, int tStay, double tExit, double tCold,			double jump0, int jumpStay, double jumpCold) {		sa.solveTrichromat(t0, tStay, tExit, tCold, jump0, jumpStay, jumpCold);		for(int i=0;i<n;i++) sa.nowLabs[i].getLMS(dlmss[i]);	}		/**	 * 実験状態を複製したいときに呼ぶ。	 * @return	 */	MinimizeExperiment copyExperiment() {		CompoundDesire newExpCompoundDesire = expCompoundDesire.copy();		boolean[] fix = new boolean[n];		LMS[] lmss = new LMS[n];		for(int j=0;j<n;j++) {			fix[j] = fixColoring[j];			lmss[j] = dlmss[j].copyLMS();		}		return new MinimizeExperiment(lmss, newExpCompoundDesire, fix, type);	}		/**	 * 総合エネルギー状態の計算メソッド	 * @return	 */	double getEnergy() {		//すべての色をLabに変換		for (int i=0;i<n;i++) dlmss[i].getLab(tempLab[i]);		//正確なエネルギー測定		double energy = 0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += expCompoundDesire.baseOfContrast(tempLab, i, j);				energy += expCompoundDesire.baseOfDistinguish(tempLab, i, j);			}			energy += expCompoundDesire.baseOfKeep(tempLab, i);		}		return energy;	}		/**	 * エネルギー状態の監視用メソッド。	 * @param cont コントラストのエネルギーテーブル	 * @param dist 	 * @param keep	 * @return	 */	double getEnergy (double[][] cont, double[][] dist, double[] keep) {		//すべての色をLabに変換		for (int i=0;i<n;i++) dlmss[i].getLab(tempLab[i]);		//正確なエネルギー測定		double energy = 0;		for (int i=0;i<n;i++) {			cont[i][i] = 0;			dist[i][i] = 0;			for (int j=i+1;j<n;j++) {				energy += cont[i][j] = cont[j][i] = expCompoundDesire.baseOfContrast(tempLab, i, j);				energy += dist[i][j] = dist[j][i] = expCompoundDesire.baseOfDistinguish(tempLab, i, j);			}			energy += keep[i] = expCompoundDesire.baseOfKeep(tempLab, i);		}		return energy;	}		/**	 * エネルギー状態の監視用メソッド	 * @param cont	 * @param dist	 * @param keep	 * @param penalty	 * @param line	 * @return	 */	String getNewtonEnergy (String[][] cont, String[][] dist, String[] keep, String[] penalty, String[] line) {		newtonEnergy = 0;		//現在のエネルギーを計算		for(int i=0;i<n;i++) {			lineNewtonTable[i] = expCompoundDesire.energyNewton				(i, dlmss, contNewtonTable, distNewtonTable, keepNewtonTable, penaltyTable, type);		}		//String の配列にセット。		for(int i=0;i<n;i++) {			cont[i][i] = ""; dist[i][i] = "";			for(int j=i+1;j<n;j++) {				cont[i][j] = cont[j][i] = ""+(int)contNewtonTable[i][j];				dist[i][j] = dist[j][i] = ""+(int)distNewtonTable[i][j];				newtonEnergy += contNewtonTable[i][j] + distNewtonTable[i][j];			}			keep[i] = ""+(int)keepNewtonTable[i];			penalty[i] = ""+(int)penaltyTable[i];			line[i] = ""+(int)lineNewtonTable[i];			newtonEnergy += keepNewtonTable[i] + penaltyTable[i];		}		return ""+(int)newtonEnergy;	}}