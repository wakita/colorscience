/* * 作成日: 2004/07/01 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @author shinamu1 */public class DesiredDistinguishability implements SimpleDesire, Serializable {	int n, type;	double[] gradOneVarAllColor, gradOneVarTwoColor;	double[][] hesseAllVarAllColor, hesseOneVarTwoColor, hesseOneVarAllColor;	LMS preLms1, preLms2, lms1, lms2;	Lab lab1, lab2;	double[][] gravity;		//static final double maxDiff = 170.0;	static final double[] dichromatMaxDiff = {135, 135, 117};		/**	 * 願望の重要度係数を受け取ってインスタンス化する。	 * @param g	 */	DesiredDistinguishability(double[][] g, int type) {		n = g.length;		this.type = type;		gravity = new double[n][n];		for(int i=0;i<n;i++) {			for (int j=0;j<n;j++) gravity[i][j]=g[i][j];		}		gradOneVarAllColor = new double[2];		gradOneVarTwoColor = new double[2];		hesseAllVarAllColor = new double[2][2];		hesseOneVarAllColor = new double[2][2];		hesseOneVarTwoColor = new double[2][2];		lms1 = new LMS(); lms2 = new LMS();		preLms1 = new LMS(); preLms2 = new LMS();		lab1 = new Lab(); lab2 = new Lab();	}		public int dimension() {		return n;	}	/**	 * 重要度の加算	 * @param dd プラスする願望	 * @return	 */	void plus(DesiredDistinguishability dd) {		assert dimension() == dd.dimension();		double gravity[][] = new double[dimension()][dimension()];		for (int i = 0; i < dimension(); i++)			for (int j = 0; j < dimension(); j++)				gravity[i][j] = this.gravity[i][j] + dd.gravity[i][j];	}	/**	 * 	 * @return	 */	double[][] getGravity() {		double[][] gravityCopy = new double[n][n];		for (int i=0;i<n;i++) 			for (int j=0;j<n;j++) gravityCopy[i][j] = gravity[i][j];		return gravityCopy;	}		/************************************************************	 *****              Lab でのエネルギー計算          *********	 ************************************************************/		public double energy(Lab[] labs, int c_i, int c_j) {		double max = dichromatMaxDiff[type-1];		if (gravity[c_i][c_j] > 0.0) {			double diff = lab1.getColorDistance76(lab2) - max;			return gravity[c_i][c_j] * diff * diff;		} else return 0.0;	}	public double energy (Lab[] labs) {		assert labs.length==n;		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) { energy += energy(labs, i, j); }		}		return energy;	}	/**	 * 各エネルギーの計算結果を保存し、総エネルギーを返す	 * @param labs	 * @param distEnergyTable	 * @return	 */	public double energy(Lab[] labs, double[][] distEnergyTable) {		assert labs.length==n;		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++)				energy += distEnergyTable[i][j] = distEnergyTable[j][i] = energy(labs, i, j);		}		return energy;	}			/************************************************************	 * ニュートン法で色盲LMS配列を用いた擬似エネルギーの計算	*	 ************************************************************/		public double energyNewton(LMS[] dlmss, int c_i, int c_j) {		double max = dichromatMaxDiff[type-1];		if (gravity[c_i][c_j] > 0.0) {			double diff = CompoundDesire.deltaDICHROLMS(dlmss[c_i], dlmss[c_j], type) - max;			return gravity[c_i][c_j] * diff * diff;		} else return 0.0;	}	public double energyNewton(LMS[] dlmss) {		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += energyNewton(dlmss, i, j);			}		}		return energy;	}	public double energyNewton(LMS[] dlmss, double[][] distEnergyTable) {		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += distEnergyTable[i][j] = distEnergyTable[j][i] =					energyNewton(dlmss, i, j);			}		}		return energy;	}		/**	 * 色差を用いたエネルギー計算	 * @param c_i	 * @param c_j	 * @param delta	 * @return	 */	public double energyNewtonWithDelta(int c_i, int c_j, double delta) {		double max = dichromatMaxDiff[type-1];		return gravity[c_i][c_j] * 				(delta * delta - 2 * max * delta + max * max);	}	/************************************************************	 * ニュートン法で用いるgradとhesseとエネルギーを同時に計算  *	 ************************************************************/		public double energyGradHesse(int c_i, int c_j, double delta,			double[] gradBase, double[] gradSq, double[][] hesseBase, double[][] hesseSq,			double[] grad, double[][] hesse) {		double max = dichromatMaxDiff[type-1];		for(int i=0;i<2;i++) {			grad[i] = gravity[c_i][c_j] * (gradSq[i]- 2 * max * gradBase[i]);			for(int j=0;j<2;j++)				hesse[i][j] = gravity[c_i][c_j]*				(hesseSq[i][j] - 2 * max * hesseBase[i][j]);		}		return gravity[c_i][c_j] * 				(delta * delta - 2*max*delta + max*max);	}		/**	 * 読み込み	 * @param in	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void readObject(ObjectInputStream in) 	throws IOException, ClassNotFoundException{		n = in.readInt();		type = in.readInt();		gravity = (double[][])in.readObject();	}		/**	 * 保存	 * @param out	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void writeObject(ObjectOutputStream out)	throws IOException, ClassNotFoundException {		out.writeInt(n);		out.write(type);		out.writeObject(gravity);	}}