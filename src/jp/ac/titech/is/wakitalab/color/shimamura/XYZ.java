/* * 作成日: 2003/11/16 * */package jp.ac.titech.is.wakitalab.color.shimamura;/** * @author shimaken * XYZの色空間 */public class XYZ extends Vector3D {		/*	 * 定数	 */			/**	 * 標準の光D65を完全拡散反射面に当てたときのX=Xn	 */		final static double Xn = 0.95045;	/**	 * 標準の光D65を完全拡散反射面に当てたときのY=Yn	 */	final static double Yn = 1.000;		/**	 * 標準の光D65を完全拡散反射面に当てたときのZ=Zn	 */	final static double Zn = 1.08892;				/**	 * XYZ to SRGB の変換行列	 */	final static Matrix3X3 matrix_toSRGB =		new Matrix3X3 (3.5064, -1.7400, -0.5441,					   -1.0690, 1.9777, 0.0352,					   0.0563, -0.19170, 1.0511);		/**	 * XYZ to RGB の変換行列	 */	final static Matrix3X3 matrix_toRGB = new Matrix3X3 (			+0.41846, -0.15860, -0.08283,			-0.09117, +0.25243, +0.01571,			+0.00092, -0.00255, +0.17860);		/**	 * XYZ to LMS の変換行列	 */	final static Matrix3X3 matrix_toLMS = new Matrix3X3 (			0.061736148218884485, 0.2542631957455062, -0.008920549199101544,			-0.11387470719474893, 0.3416329047942756, 0.02898118728581802, 			4.8748948189481E-4, -0.0013522537833399904, 0.16433022874773098);		static XYZ tempXYZ = new XYZ();			/*	 * コンストラクター	 */			/**	 * 全成分を0で初期化するコンストラクター	 */	public XYZ () {		super();	}		/**	 * double をとるコンストラクター	 */	public XYZ (double value1, double value2, double value3) {		super(value1, value2, value3);		positiver();	}		/**	 * int をとるコンストラクター	 */	public XYZ (int value1, int value2, int value3) {		super(value1, value2, value3);		positiver();	}		/**	 * double 配列をとるコンストラクター	 */	public XYZ (double values[]) {		super(values);		positiver();	}		/**	 * Vector3D をとるコンストラクター	 */	public XYZ (Vector3D v) {		super(v);		positiver();	}			/*	 * メソッド	 */				/**	 * X を指定する。マイナスを0にする	 */	void setValue1(double value) {		super.setValue1(value);		positiver1();	}		/**	 * Y を指定する。マイナスを0にする	 */	void setValue2(double value) {		super.setValue2(value);		positiver2();	}		/**	 * Z を指定する。マイナスを0にする	 */	void setValue3(double value) {		super.setValue3(value);		positiver3();	}		/**	 * SRGBに変換	 * @return SRGB	 */	SRGB getSRGB() {		SRGB srgb = new SRGB(matrix_toSRGB.convertVector3D((Vector3D)this));		srgb.setValue(			gammaRevise(srgb.getValue1()),			gammaRevise(srgb.getValue2()),			gammaRevise(srgb.getValue3()));		return srgb;	}		/**	 * SRGBに変換。メモリーを与えて素早くしよう。	 * @param srgb	 * @return	 */	boolean getSRGB(SRGB srgb) {		boolean isRevised = false;		tempValues[0] = getValue1();		tempValues[1] = getValue2();		tempValues[2] = getValue3();		matrix_toSRGB.convertDoubles(tempValues);		if (tempValues[0]<0.0 | tempValues[1]<0.0 | tempValues[2]<0.0) {			isRevised = true;		}		srgb.setValue(			gammaRevise(tempValues[0]),			gammaRevise(tempValues[1]),			gammaRevise(tempValues[2]));		return isRevised;	}		/**	 * RGBに変換	 * @return RGB	 */	RGB getRGB() {		RGB ret = new RGB(matrix_toRGB.convertVector3D((Vector3D)this));		return ret;	}	/**	 * RGBに変換。メモリーを与える。	 * @param returnRGB	 * @return	 */	RGB getRGB(RGB returnRGB) {		getDoubles(tempValues);		matrix_toRGB.convertDoubles(tempValues);		returnRGB.setValue(tempValues[0], tempValues[1], tempValues[2]);		return returnRGB;	}		/**	 * Labに変換	 * @return Lab	 */	Lab getLab() {		double xxn = getValue1()/Xn;		double yyn = getValue2()/Yn;		double zzn = getValue3()/Zn;		double l = 116.0 * f(yyn) - 16.0;		double a = 500.0 * (f(xxn) - f(yyn));		double b = 200.0 * (f(yyn) - f(zzn));		Lab ret = new Lab (l, a, b);//		Lab ret = new Lab (l*0.01, a*0.01, b*0.01);	 	return ret;	 }	 	 /**	  * Labに変換。メモリーを与えて素早くしよう。	  * @param lab	  */	 void getLab(Lab lab) {		double xxn = getValue1()/Xn;		double yyn = getValue2()/Yn;		double zzn = getValue3()/Zn;		double fyyn = f(yyn);		lab.setValue(			116.0 * fyyn - 16.0,			500.0 * (f(xxn) - fyyn),			200.0 * (fyyn - f(zzn)));/*		lab.setValue(			(116.0 * f(yyn) - 16.0)*0.01,			(500.0 * (f(xxn) - f(yyn)))*0.01,			(200.0 * (f(yyn) - f(zzn))))*0.01;*/	 }	 /**	  * Labに変換。ただし関数 f に if文はなく、f(x) = x^(1/3)	  * @param lab	  */	 void getLab_13(Lab lab) {		double xxn = getValue1()/Xn;		double yyn = getValue2()/Yn;		double zzn = getValue3()/Zn;		double fyyn = f_13(yyn);		lab.setValue(			116.0 * fyyn - 16.0,			500.0 * (f_13(xxn) - fyyn),			200.0 * (fyyn - f_13(zzn)));	 }	 	 Luv1976 getLuv1976() {	 	double x = getValue1();	 	double y = getValue2();	 	double z = getValue3();	 	double bunbo = x + 15 * y + 3 * z;		double u_;		double v_;	 	if (bunbo != 0.0) {			u_ = (4.0 * x) / bunbo;			v_ = (9.0 * y) / bunbo;	 	} else {	 		u_ = v_ = 0.0;	 	}	 	double l = getLuv1976L(y/Yn);	 	double u = 13 * l * (u_ - Luv1976.un);	 	double v = 13 * l * (v_ - Luv1976.vn);	 	return new Luv1976(l, u, v);	 }	 	 void getLuv1976(Luv1976 luv) {		double x = getValue1();		double y = getValue2();		double z = getValue3();		double bunbo = x + 15 * y + 3 * z;		double u_;		double v_;		if (bunbo != 0.0) {			u_ = (4.0 * x) / bunbo;			v_ = (9.0 * y) / bunbo;		} else {			u_ = v_ = 0.0;		}		double l = getLuv1976L(y/Yn);		double u = 13 * l * (u_ - Luv1976.un);		double v = 13 * l * (v_ - Luv1976.vn);		luv.setValue(l, u, v);	 }	 	 /**	  * LMSに変換。	  * @return	  */	 LMS getLMS() {		LMS ret = new LMS(matrix_toLMS.convertVector3D((Vector3D)this));		return ret;	 }	 /**	  * LMSに変換。メモリー与える。	  * @param returnLMS	  * @return	  */	 LMS getLMS(LMS returnLMS) {		getDoubles(tempValues);		matrix_toLMS.convertDoubles(tempValues);		returnLMS.setValue(tempValues[0], tempValues[1], tempValues[2]);		return returnLMS;	 }		/**	 * 関数 f	 * 小さいときは直線で、大きいときは1/3乗	 * @param double q	 * @return double	 */	static double f (double q) {		if (q < 0.008856) {			double ret = 7.787*q + 16.0/116.0;			return ret;		} else {			double ret =Math.pow(q, 1.0/3.0);			return ret;		}	}		/**	 * if 文を抜いた xyz ->lab に使う関数 f() もどき	 * @param q	 * @return	 */	static double f_13 (double q) { return Math.pow(q, 1.0/3.0); }		/**	 * Luv1976の明度指数 L* を計算する	 * @param yyn Y/Yn のこと	 * @return	 */	static double getLuv1976L (double yyn) {		if (yyn < 0.008856) {			return 903.29 * yyn;		} else {			return 116.0 * Math.pow(yyn, 1.0/3.0) - 16.0;		}	}		/**	 * ガンマの逆変換	 * @param value　変換前	 * @return 変換後	 */	public static double gammaRevise(double value) {		double ret = Math.pow(value, 1.0/SRGB.GAMMA);		if (Double.isNaN(ret)) {			ret = 0.0;		}		return ret;	}		/**	 * SRGB変換時の、ガンマ変換をする手前で境界補正	 * @param tempValues	 * @return	 */	boolean boundaryReviseSRGBdash() {		boolean isRevised = false;		for(int i=0;i<3;i++) tempValues[i] = getValue(i);		matrix_toSRGB.convertDoubles(tempValues);		double overMax = 0.0;		for (int i=0;i<3;i++) {			overMax = Math.max(overMax, -tempValues[i]);			overMax = Math.max(overMax, tempValues[i]-1.0);		}		if (isRevised=(overMax>0)) {			double scale = 0.5 / (overMax + 0.5);			for (int i=0;i<3;i++) tempValues[i] = (tempValues[i] - 0.5) * scale + 0.5;		}		SRGB.matrix_toXYZ.convertDoubles(tempValues);		setValue(tempValues[0], tempValues[1], tempValues[2]);		return isRevised;	}		public SRGBdash getSRGBdash() {		SRGBdash newSrgbDash = new SRGBdash();		newSrgbDash.setVector3d(matrix_toSRGB.convertVector3D((Vector3D)this));		return newSrgbDash;	}	/**	 * This makes this as SRGBdash in srgb_dash	 * @param srgb_dash	 */	public boolean getSRGBdash(SRGBdash srgb_dash) {		matrix_toSRGB.convertVector3D((Vector3D)this, (Vector3D)srgb_dash);		return false;	}}