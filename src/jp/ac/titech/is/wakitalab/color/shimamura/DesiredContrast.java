/* * 作成日: 2004/07/01 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @author shinamu1 */public class DesiredContrast implements SimpleDesire, Serializable {	int n, type;	double[] gradOneVarAllColor, gradOneVarTwoColor;	double[][] hesseAllVarAllColor, hesseOneVarTwoColor, hesseOneVarAllColor;	/**	 * IdealDistance	 */	double[][] ideal;	double[][] gravity;	static final double[] dichromatDelta = {1.0, 135.0/170.0, 135.0/170.0, 117.0/170.0};		LMS preLms1, preLms2, lms1, lms2;		/************************************************************	 *						コンストラクター					*	 ************************************************************/		// 色差計算の元のLab　をとるコンストラクタ	DesiredContrast (Lab[] idealLabs, double[][] gravity, int type) {		n = gravity.length;		ideal = new double[n][n];		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++)				ideal[i][j] = ideal[j][i] =					idealLabs[i].getColorDistance76(idealLabs[j]) * dichromatDelta[type];		}		initialize(gravity, type);	}	// 理想値　をとるコンストラクタ	public DesiredContrast (double[][] anotherIdeal, double[][] gravity, int type) {		n = gravity.length;		ideal = new double[n][n];		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) ideal[i][j] = anotherIdeal[i][j];		}		initialize(gravity, type);	}	// initializer	private void initialize(double[][] gravity, int type) {		this.type = type;		this.gravity = new double[n][n];		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) {				this.gravity[i][j] = gravity[i][j];			}		}		lms1 = new LMS(); lms2 = new LMS();		preLms1 = new LMS(); preLms2 = new LMS();	}		public int dimension() { return n; }	/**	 * 重要度の加算	 * 色盲タイプの種わけをしたほうがよい	 * @param dc	 */	void plus(DesiredContrast dc) {		assert dimension() == dc.dimension();		double gravity[][] = new double[dimension()][dimension()];		for (int i = 0; i < dimension(); i++)			for (int j = 0; j < dimension(); j++)				gravity[i][j] = this.gravity[i][j] + dc.gravity[i][j];	}		/************************************************************	 *						願望度と理想値の閲覧				*	 ************************************************************/		/**	 * 願望のコピー	 * @return	 */	double[][] getGravity() {		double[][] gravityCopy = new double[n][n];		for (int i=0;i<n;i++)			for (int j=0;j<n;j++) gravityCopy[i][j] = gravity[i][j];		return gravityCopy;	}		/**	 * コントラストの理想値を配列に入れて返す	 * @param ideal	 */	void getIdeal(double[][] ideal) {		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) ideal[i][j] = this.ideal[i][j]; }	}	double[][] getIdeal () {		double[][] idealCopy = new double[n][n];		for (int i=0;i<n;i++)			for (int j=0;j<n;j++) idealCopy[i][j] = ideal[i][j];		return idealCopy;	}	/**	 * コントラストの理想値を返す	 * @param i 色番号	 * @param j 色番号	 * @return	 */	double getIdeal (int i, int j) { return ideal[i][j]; }				/************************************************************	 *****              Lab でのエネルギー計算          *********	 ************************************************************/			public double energy(Lab[] labs, int i, int j) {		if (gravity[i][j]>0.0) {			double delta = 	(labs[i].getColorDistance76(labs[j]) - ideal[i][j]);			return gravity[i][j] * delta * delta;		}		else return 0.0;	}		public double energy(Lab[] labs) {		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++)				energy += energy(labs, i, j);		}		return energy;	}		public double energy(Lab[] labs, double[][] contEnergyTable) {		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += contEnergyTable[i][j] = contEnergyTable[j][i] = energy(labs, i, j);			}		}		return energy;	}		/************************************************************	 * ニュートン法で色盲LMS配列を用いた擬似エネルギーの計算	*	 ************************************************************/		/**	 * c_iとc_j間のエネルギーを計算	 * @param dlmss	 * @param c_i	 * @param c_j	 * @return	 */	public double energyNewton(LMS[] dlmss, int c_i, int c_j) {		if (gravity[c_i][c_j] > 0.0) {			double diff = CompoundDesire.deltaDICHROLMS(dlmss[c_i], dlmss[c_j], type) - ideal[c_i][c_j];			return gravity[c_i][c_j] * diff * diff;		} else return 0.0;	}	/**	 * すべてのエネルギーを計算	 * @param dlmss	 * @return 	 */	public double energyNewton(LMS[] dlmss) {		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += energyNewton(dlmss, i, j);			}		}		return energy;	}	/**	 * すべてのエネルギーを計算し、各エネルギーをテーブルに保存	 * @param dlmss	 * @param contEnergyTable 保存するエネルギーテーブル	 * @return	 */	public double energyNewton(LMS[] dlmss, double[][] contEnergyTable) {		assert dlmss!=null && dlmss.length==n && contEnergyTable!=null && contEnergyTable.length==n;		double energy = 0.0;		for (int i=0;i<n;i++) {			for (int j=i+1;j<n;j++) {				energy += contEnergyTable[i][j] = contEnergyTable[j][i] =					energyNewton(dlmss, i, j);			}		}		return energy;	}	/**	 * 色差を使ったエネルギー計算	 * @param c_i	 * @param c_j	 * @param delta 既に計算されたc_i,c_j間の色差	 * @return	 */	public double energyNewtonWithDelta(int c_i, int c_j, double delta) {		return gravity[c_i][c_j] *			delta*delta - 2*ideal[c_i][c_j]*delta + ideal[c_i][c_j]*ideal[c_i][c_j];	}	/******************************************************************	 * ニュートン法で用いるgradとhesseとエネルギーの同時計算メソッド  *	 ******************************************************************/		/**	 * c_i を変数の色番号、c_j をもう一つの色番号、としたときの、	 * 色差とその一次微分二次微分、色差の二乗の一次微分と二次微分、を引き数にとり、	 * エネルギーとその一次微分二次微分を返す。	 * @param c_i	 * @param c_j	 * @param delta 色差値	 * @param gradBase 色差の一次微分	 * @param gradSq 色差の二乗の一次微分	 * @param hesseBase 色差の二次微分	 * @param hesseSq 色差の二乗の二次微分	 * @param grad エネルギーの一次微分（出力	 * @param hesse エネルギーの二次微分（出力	 * @param エネルギー値（出力	 */	public double energyGradHesse(int c_i, int c_j, double delta,			double[] gradBase, double[] gradSq, double[][] hesseBase,double[][] hesseSq,			double[] grad, double[][] hesse) {		for(int i=0;i<2;i++) {			grad[i] = gravity[c_i][c_j] * (gradSq[i]- 2 * ideal[c_i][c_j] * gradBase[i]);			for(int j=0;j<2;j++)				hesse[i][j] = gravity[c_i][c_j]*				(hesseSq[i][j] - 2 * ideal[c_i][c_j] * hesseBase[i][j]);		}		return gravity[c_i][c_j] *				delta*delta - 2*ideal[c_i][c_j]*delta + ideal[c_i][c_j]*ideal[c_i][c_j];	}		/**	 * 読み込み	 * @param in	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void readObject(ObjectInputStream in) 	throws IOException, ClassNotFoundException{		n = in.readInt();		type = in.readInt();		ideal = (double[][])in.readObject();		gravity = (double[][])in.readObject();	}		/**	 * 保存	 * @param out	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void writeObject(ObjectOutputStream out)	throws IOException, ClassNotFoundException {		out.writeInt(n);		out.write(type);		out.writeObject(ideal);		out.writeObject(gravity);	}}