/* * 作成日: 2004/05/21 * TODO バグ　SA dialog を×で閉じたときに、SAのメニューが復活しない。 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.awt.*;import java.awt.event.*;import javax.swing.*;//-------------------------------------------------------------------------------------------------/** * @author shinamu1 */public class IromieGUI extends JFrame {		//--------------------------------------------------------------------------------------------		/************************************************************	 *						フィールドの宣言					*	 ************************************************************/		/**	 * the default length for new window	 */	final static int DEFAULT_H = 800, DEFAULT_W = 800;	/**	 * the new window's max number of buttons	 */	final static int BUTTON_NUM = 50;		final static int STATE_TRICHROMATIC=0, STATE_PROTANOPE=1, STATE_DEUTERANOPE=2, STATE_TRITANOPE=3;	final static int STATE_PROTANOPE_REPAINT=4, STATE_DEUTERANOPE_REPAINT=5, STATE_TRITANOPE_REPAINT=6;	final static int STATE_DICHROMAT=7, STATE_DICHROMAT_REPAINT=8, STATE_EACH_REPAINT=9;		/**	 * core program	 */	private Iromie iromie;	private FileDialog fileDialog, saveFileDialog;		private MenuItem saveItem, loadStateItem, saveStateItem;	private MenuItem medianItem, laplacian34Item, laplacian38Item, laplacian98Item;	private MenuItem acute34Item, acute38Item, acute98Item;	private MenuItem kClusteringItem;	private MenuItem proItem, deuItem, triItem, dichroItem;	private MenuItem distinguishItem, contrastItem, keepItem;	private MenuItem saItemPro, saItemDeu, saItemTri;	private MenuItem saItemProView, saItemDeuView, saItemTriView, saItemDichro;	private MenuItem newtonRaphsonItem, roughSAandNewtonItem, expSAItem, trichromatSAItem;			private Label msgLabel, originalLabel;	private Panel panelEast, panelCenter, panelWest;	private Panel[] buttonPanel, tetraPanel;	private Button[] button, dichromatButton;	private Button allDichromatButton;	private Label[] selfLabel, relationLabel, tripleLabel;	private BitmapCanvas canvas;	private BitmapCanvas[] tripleCanvas;	private boolean clickable;	private int reprK;	private IntVector reprKVector;	private int[] reprKInt;	@SuppressWarnings("unused")	private ColorOBJ shelterColorOBJ, dragColorOBJ;	private boolean dragBool;	@SuppressWarnings("unused")	private SRGB dragSRGB;	boolean autoClusteringBoolean = true; // bmp の入力は即クラスタリングする、というフラグ	boolean autoSetParameterForSimulatedAnnealing = true;	private int state = IromieGUI.STATE_TRICHROMATIC;			//--------------------------------------------------------------------------------------------		/************************************************************	 *						コンストラクタ						*	 ************************************************************/		public IromieGUI() {		iromie = new Iromie();		fileDialog = new FileDialog(this, "画像ファイルの選択", FileDialog.LOAD);		saveFileDialog = new FileDialog(this, "保存する", FileDialog.SAVE);		MenuBar menuBar = new MenuBar();		Menu fileMenu = new Menu("ファイル");		MenuItem openItem = new MenuItem("開く");		saveItem = new MenuItem("保存");		loadStateItem = new MenuItem("状態読み込み");		saveStateItem = new MenuItem("状態保存");		MenuItem exitItem = new MenuItem("終了");		Menu filterMenu = new Menu("フィルター");		MenuItem originalItem = new MenuItem("元画像");		medianItem = new MenuItem("中央値フィルター");		laplacian34Item = new MenuItem("４方向３３ラプラシアンフィルター");		laplacian38Item = new MenuItem("８方向３３ラプラシアンフィルター");		laplacian98Item = new MenuItem("８方向９９ラプラシアンフィルター");		acute34Item = new MenuItem("４方向３３ラプラシアン先鋭フィルター");		acute38Item = new MenuItem("８方向３３ラプラシアン先鋭フィルター");		acute98Item = new MenuItem("８方向９９ラプラシアン先鋭フィルター");		kClusteringItem = new MenuItem("Ｋクラスタリング");		Menu dichromatMenu = new Menu("色盲変換");		proItem = new MenuItem("第一色盲変換");		deuItem = new MenuItem("第二色盲変換");		triItem = new MenuItem("第三色盲変換");		dichroItem = new MenuItem("全三種色盲変換");		Menu repaintMenu = new Menu("再配色");		distinguishItem = new MenuItem("識別の重要度");		contrastItem = new MenuItem("コントラストの重要度");		keepItem = new MenuItem("保存の重要度");		Menu saMenu = new Menu("SimulatedAnnealing法");		saItemPro = new MenuItem("第一色盲");		saItemDeu = new MenuItem("第二色盲");		saItemTri = new MenuItem("第三色盲");		saItemDichro = new MenuItem("全三種");		saItemProView = new MenuItem("第一色盲プレゼン");		saItemDeuView = new MenuItem("第二色盲プレゼン");		saItemTriView = new MenuItem("第三色盲プレゼン");		newtonRaphsonItem = new MenuItem("NewtonRaphson法");		roughSAandNewtonItem = new MenuItem("SA and Newton");		expSAItem = new MenuItem("SA");		trichromatSAItem = new MenuItem("Trichromat SA");		msgLabel = new Label("画像が入力されていません");		panelEast = new Panel();		buttonPanel = new Panel[BUTTON_NUM];		button = new Button[BUTTON_NUM];		selfLabel = new Label[BUTTON_NUM];		relationLabel = new Label[BUTTON_NUM];		canvas = new BitmapCanvas();		panelCenter = new Panel();		panelWest = new Panel();		allDichromatButton = new Button("All");		tripleCanvas = new BitmapCanvas[3];		dichromatButton = new Button[3];		tripleLabel = new Label[3];		for (int i=0;i<3;i++) {			dichromatButton[i] = new Button(Dichromat.typeString(i+1));			tripleCanvas[i] = new BitmapCanvas();			tripleLabel[i] = new Label();		}		originalLabel = new Label();		tetraPanel = new Panel[4];		for (int i=0;i<4;i++) {			tetraPanel[i] = new Panel();		}		clickable = false;		reprK = 0;		dragBool = false;		dragColorOBJ = new ColorOBJ(0);		dragSRGB = new SRGB();						// コンポーネントの設定		setFilterMenuItemsEnabled(false);		setDichromatMenuItemsEnabled(false);		setRepaintMenuItemsEnabled(false);		openItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				openCommand();			}		});		saveItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				saveCommand();			}		});		loadStateItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				loadStateCommand();			}		});		saveStateItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				saveStateCommand();			}		});		exitItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				System.out.println("exit is pressed");				exitCommand();			}		});		originalItem.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				originalCommand();			}		});		medianItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				medianCommand();			}		});		laplacian34Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				laplacian34Command();			}		});		laplacian38Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				laplacian38Command();			}		});		laplacian98Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				laplacian98Command();			}		});		acute34Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				acute34Command();			}		});		acute38Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				acute38Command();			}		});		acute98Item.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				acute98Command();			}		});		kClusteringItem.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				kClusteringCommand();			}		});		proItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				dichromatCommand(Dichromat.PROTANOPE);			}		});		deuItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				dichromatCommand(Dichromat.DEUTERANOPE);			}		});		triItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				dichromatCommand(Dichromat.TRITANOPE);			}		});		dichroItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				drawAllTypeViewCommand();			}		});		distinguishItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				distinguishCommand();			}		});		contrastItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				contrastCommand();			}		});		keepItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				keepCommand();			}		});		saItemPro.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				simulatedAnnealingCommand(Dichromat.PROTANOPE);			}		});		saItemDeu.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				simulatedAnnealingCommand(Dichromat.DEUTERANOPE);			}		});		saItemTri.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				simulatedAnnealingCommand(Dichromat.TRITANOPE);			}		});		saItemDichro.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				drawEachTypeRepaintCommand();			}		});		saItemProView.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				drawRepaintSystemCommand(Dichromat.PROTANOPE);			}		});		saItemDeuView.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				drawRepaintSystemCommand(Dichromat.DEUTERANOPE);			}		});		saItemTriView.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				drawRepaintSystemCommand(Dichromat.TRITANOPE);			}		});		newtonRaphsonItem.addActionListener(new ActionListener(){			public void actionPerformed(ActionEvent e) {				newtonRaphsonCommand();			}		});		roughSAandNewtonItem.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				roughSAandNewtonCommand();			}		});		expSAItem.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				expSimulatedAnnealingCommand();			}		});		trichromatSAItem.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				trichromatSimulatedAnnealingCommand();			}		});		canvas.addMouseListener(new MouseAdapter() {			public void mouseClicked(MouseEvent me) {				if (clickable) {					int x = me.getX();					int y = me.getY();					System.out.println("Clicked at (" + x + ", " + y + ")");					SRGB srgb;					try {						srgb = iromie.getSRGB(x, y);					} catch (ArrayIndexOutOfBoundsException e) {						return;					}					System.out.println("this color is (" + srgb.getValue1() + ", " + srgb.getValue2() + ", " + srgb.getValue3() + ")");					reprKVector.add(iromie.getInt(x, y));					button[reprK].setLabel("  ");					button[reprK].setBackground(new Color(srgb.getInt()));					selfLabel[reprK].setText(						"("+(int)(255.0*srgb.getValue1())+", "						+(int)(255.0*srgb.getValue2())+", "						+(int)(255.0*srgb.getValue3())+")");					Luv1976 luv = new Luv1976();					// XYZ xyz = new XYZ();					// double[] td = new double[3];					srgb.getLuv1976(luv);					luv = srgb.getLuv1976();					SRGB srgb2 = luv.getSRGB();					luv.getSRGB(srgb2);					reprK++;				}			}			public void mouseReleased(MouseEvent me) {				if (dragBool) {					iromie.drawCanvas(canvas);				}			}		});		// マウスドラッグ		canvas.addMouseMotionListener(new MouseMotionAdapter() {			/*			public void mouseDragged(MouseEvent me) {				if (iromie.colorUnificationBoolean) {					int x = me.getX();					int y = me.getY();					if (x>-1 && y > -1 && x<iromie.getW() && y<iromie.getH()) {						int[][] areaPixels = iromie.getAreaPixels();						int num = areaPixels[y][x];						dragSRGB = new SRGB(iromie.getAreaSRGB(num).copy());						dragSRGB.setValue(0.5*dragSRGB.getValue1(), 0.5*dragSRGB.getValue2(), 0.5*dragSRGB.getValue3());						System.out.println("("+dragSRGB.getValue1()+", "+dragSRGB.getValue2()+", "+dragSRGB.getValue3()+") ");						dragColorOBJ = new ColorOBJ(0);						dragColorOBJ.setFirstSRGB(dragSRGB.getInt());						dragColorOBJ.setRepresentFirst();						AreaOBJ areaOBJ = iromie.getAreaOBJ(num);						// 元の色OBJを退避させる						shelterColorOBJ = areaOBJ.getColorOBJ();						// ドラッグ用の色OBJに差し替える。						areaOBJ.setColorOBJ(dragColorOBJ);						iromie.drawCanvas(canvas);						areaOBJ.setColorOBJ(shelterColorOBJ);						dragBool = true;					}				}				System.out.println("Dragged");			}			*/		});		/*		 * ボタンの初期化 : East-Panel		 */ 		panelEast.setLayout(new GridLayout(BUTTON_NUM, 1));		for (int i=0;i<BUTTON_NUM;i++) {			final int j = i;			buttonPanel[i] = new Panel(new GridLayout(1,3));			selfLabel[i] = new Label("                                              ");			relationLabel[i] = new Label("                                              ");			button[i] = new Button();			button[i].addActionListener(new ActionListener() {				public void actionPerformed(ActionEvent e) {					buttonCommand(j);				}			});			buttonPanel[i].add(button[i]);			buttonPanel[i].add(selfLabel[i]);			buttonPanel[i].add(relationLabel[i]);			panelEast.add(buttonPanel[i]);		}				/*		 * 中央のキャンバスなどの初期化 : Center-Panel with Tetra-Panel		 */ 		panelCenter.setLayout(new GridLayout(2,2));		for (int i=0;i<4;i++) {			tetraPanel[i].setLayout(new BorderLayout());			panelCenter.add(tetraPanel[i]);		}		// Original		tetraPanel[0].add(originalLabel, BorderLayout.NORTH);		tetraPanel[0].add(canvas, BorderLayout.CENTER);		// D-click on BitmapCanvas, shows Each-Repaint viewed by Each-Dichromat		for (int i=0;i<3;i++) {			final int j = i;			tripleCanvas[j].addMouseListener(new MouseAdapter() {				public void mouseClicked(MouseEvent e) {					if (e.getClickCount()==2) {// when double click is occured, repainting occure						if (state == IromieGUI.STATE_DICHROMAT) {// when all-dichromat-view viewed							drawAllTypeViewOfRepaintCommand(j+1);						}					}				}			});		}		// D-click show Repaint-System		tetraPanel[2].addMouseListener(new MouseAdapter() {			public void mouseClicked(MouseEvent e) {				if (e.getClickCount()==2) {					if (state > 0 && state < 4) {// when each dichromat-view viewed 						drawRepaintSystemCommand(state);					}				}			}		});				/*		 * 左のボタンなどの初期化 : West-Panel		 */		//panelWest.setLayout(new SpringLayout());		panelWest.setSize(200, DEFAULT_H);		for (int i=0;i<3;i++) {			final int j = i;			// each dichromat button			panelWest.add(dichromatButton[j]);			dichromatButton[j].addActionListener(new ActionListener() {				public void actionPerformed(ActionEvent e) {					drawDichromatCommand(j);				}			});		}		allDichromatButton.setSize(150, DEFAULT_H/2);		panelWest.add(allDichromatButton);		panelWest.validate();		// all-dichromat button		allDichromatButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent e) {				drawAllTypeViewCommand();			}		});				/*		 * 全パネルの設置		 */		getContentPane().setLayout(new BorderLayout());		getContentPane().add(msgLabel, BorderLayout.SOUTH);		getContentPane().add(panelCenter, BorderLayout.CENTER);		//getContentPane().add(panelEast, BorderLayout.EAST);		getContentPane().add(panelWest, BorderLayout.NORTH);				/*		 * メニューアイテムの設置		 */		setMenuBar(menuBar);		menuBar.add(fileMenu);		fileMenu.add(openItem);		fileMenu.add(saveItem);		fileMenu.add(loadStateItem);		fileMenu.add(saveStateItem);		fileMenu.addSeparator();		fileMenu.add(exitItem);		menuBar.add(filterMenu);		filterMenu.add(originalItem);		filterMenu.add(medianItem);		filterMenu.add(laplacian34Item);		filterMenu.add(laplacian38Item);		filterMenu.add(laplacian98Item);		filterMenu.add(acute34Item);		filterMenu.add(acute38Item);		filterMenu.add(acute98Item);		filterMenu.add(kClusteringItem);		menuBar.add(dichromatMenu);		dichromatMenu.add(proItem);		dichromatMenu.add(deuItem);		dichromatMenu.add(triItem);		dichromatMenu.add(dichroItem);		menuBar.add(repaintMenu);		repaintMenu.add(distinguishItem);		repaintMenu.add(contrastItem);		repaintMenu.add(keepItem);		repaintMenu.addSeparator();		repaintMenu.add(saMenu);		saMenu.add(saItemPro);		saMenu.add(saItemDeu);		saMenu.add(saItemTri);		saMenu.add(saItemDichro);		saMenu.add(saItemProView);		saMenu.add(saItemDeuView);		saMenu.add(saItemTriView);		repaintMenu.add(newtonRaphsonItem);		repaintMenu.add(roughSAandNewtonItem);		repaintMenu.add(expSAItem);		repaintMenu.add(trichromatSAItem);				// ウインドウクローズイベント		addWindowListener(new WindowAdapter(){			public void windowClosing(WindowEvent e){				System.out.println("exit is listened.");				exitCommand();			}		});				// ドラッグアンドドロップを実行？？				/*		DropTargetAdapter dtListener = new DropTargetAdapter(){			public void drop(DropTargetDropEvent e) {				e.acceptDrop(e.getDropAction());				msgLabel.setText("ドロップ画像を入力中です。");				DataFlavor[] dFlavors = e.getCurrentDataFlavors();				for(int i = 0; i < dFlavors.length; i ++){					try {						List list = (List)e.getTransferable().getTransferData(dFlavors[i]);						if(list.size() > 0){							File file = (File)list.get(0);							String fileName = file.getAbsolutePath();							msgLabel.setText(fileName + " ファイルの領域認識中です。");							openCommandChild(fileName);						}					} catch (UnsupportedFlavorException e1) {						// ドラッグアンドドロップに失敗しても何もしない					} catch (IOException e1) {						// ドラッグアンドドロップに失敗しても何もしない					}					catch (Exception e1) {						// ドラッグアンドドロップに失敗しても何もしない					}				}			}		};		*/				// DropTarget dTarget = new DropTarget(this, dtListener);	}		//----------------------------------------------------------------------------------------------		/************************************************************	 *							入出力							*	 ************************************************************/		/**	 * 「開く」が押された時の動作。	 */	public void openCommand(){		fileDialog.setVisible(true);		String dirName = fileDialog.getDirectory();		String fileName = fileDialog.getFile();		if(dirName == null || dirName.equals("")){			msgLabel.setText("画像が入力されていません");			return;		}		if(fileName == null || fileName.equals("")){			msgLabel.setText("画像が入力されていません");			return;		}		String fullPath = dirName + fileName;		msgLabel.setText(fileName + " ファイルの形式を解析中です。");		openCommandChild(fullPath);	}	/**	 * 開く操作（開くorドラッグ＆ドロップが呼び出す）	 * @param fileName	 */	private void openCommandChild(String fileName) {		originalLabel.setText("Original");		resetState();		for (int i=0;i<BUTTON_NUM;i++) {			button[i].setBackground(new Color(0.8f,0.8f,0.8f));		}		if (fileName.toUpperCase().endsWith(".BMP")) {			msgLabel.setText("BMP: " + fileName + "を読み込んでいます。");			iromie.readBitmap(fileName);			setRepaintMenuItemsEnabled(false);		} else if (		fileName.toUpperCase().endsWith(".JPG") ||		fileName.toUpperCase().endsWith(".JPEG")) {			msgLabel.setText("JPEG: " + fileName + "を読み込んでいます。");			iromie.readJpeg(fileName);			setRepaintMenuItemsEnabled(false);		} else if (fileName.toUpperCase().endsWith(".TXT")) {			msgLabel.setText("TXT: " + fileName + "を読み込んでいます。");			iromie.readTextColoringInformation(fileName);			double[] kepG = iromie.getKeepGravity();			for (int i=0;i<iromie.getColorOBJNum();i++) {				SRGB srgb = iromie.getColorOBJ(i).getFirstSRGB();				button[i].setBackground(new Color(srgb.getInt()));				selfLabel[i].setText("("+(int)255*srgb.getValue1()+", "+(int)255*srgb.getValue2()+", "+(int)255*srgb.getValue3()+")"				+" K:"+kepG[i]+" ");			}			setRepaintMenuItemsEnabled(true);		}		msgLabel.setText(fileName + "ファイルを読み込みました。");		//入力した画像の表示		iromie.setOriginalPixels();		iromie.setRepresentFirst();		iromie.drawCanvas(canvas);		//メニューを選択可能にする		setFilterMenuItemsEnabled(true);		setDichromatMenuItemsEnabled(true);		// 入力直後にBMP画像をＫクラスタリングする		if (autoClusteringBoolean && fileName.toUpperCase().endsWith(".BMP")) {			iromie.unificationClear();			iromie.autoClustering();			int colorNum = iromie.getColorOBJNum();			for (int i=0;i<colorNum;i++) {				button[i].setLabel("  ");				SRGB srgb = iromie.getColorOBJ(i).getFirstSRGB();				button[i].setBackground(new Color(srgb.getInt()));				selfLabel[i].setText(						"("+(int)(255.0*srgb.getValue1())+", "						+(int)(255.0*srgb.getValue2())+", "						+(int)(255.0*srgb.getValue3())+")");			}			//Ｋクラスタリング後の画像を提示			iromie.setReducePixels();			iromie.drawCanvas(canvas);			// メニューを選択可能にする			setRepaintMenuItemsEnabled(true);		}	}	/**	 * 「保存」時の動作	 */	private void saveCommand() {		saveFileDialog.setVisible(true);		String dirName = saveFileDialog.getDirectory();		String fileName = saveFileDialog.getFile();		if(dirName == null || dirName.equals("")){			msgLabel.setText("保存名が入力されていません");			return;		}		if(fileName == null || fileName.equals("")){			msgLabel.setText("保存名が入力されていません");			return;		}		String fullPath = dirName + fileName;		msgLabel.setText(fullPath + " ファイルを保存中です。");		iromie.saveXML(fullPath);		msgLabel.setText(fullPath + " 保存が終了しました。");	}	/**	 * 状態読み込みコマンド	 */	private void loadStateCommand() {		fileDialog.setVisible(true);		String dirName = fileDialog.getDirectory();		String fileName = fileDialog.getFile();		if(dirName == null || dirName.equals("")){			msgLabel.setText("ファイル名が入力されていません");			return;		}		if(fileName == null || fileName.equals("")){			msgLabel.setText("ファイル名が入力されていません");			return;		}		String fullPath = dirName + fileName;		msgLabel.setText(fullPath + " ファイルを読み込み中です。");		iromie.loadState(fullPath);		msgLabel.setText(fullPath + " 読み込み終了しました。");		setDichromatMenuItemsEnabled(true);		setRepaintMenuItemsEnabled(true);	}	/**	 * 状態保存コマンド	 */	private void saveStateCommand() {		saveFileDialog.setVisible(true);		String dirName = saveFileDialog.getDirectory();		String fileName = saveFileDialog.getFile();		if(dirName == null || dirName.equals("")){			msgLabel.setText("ファイル名が入力されていません");			return;		}		if(fileName == null || fileName.equals("")){			msgLabel.setText("ファイル名が入力されていません");			return;		}		String fullPath = dirName + fileName;		msgLabel.setText(fullPath + " ファイルを読み込み中です。");		iromie.saveState(fullPath);		msgLabel.setText(fullPath + " 保存終了しました。");	}	/**	 * 「終了」時の動作	 */	private void exitCommand(){		System.exit(0);	}		//----------------------------------------------------------------------------------------------		/************************************************************	 *						フィルタリング						*	 ************************************************************/		/**	 * 「元画像」時の動作	 */	private void originalCommand() {		iromie.setOriginalPixels();		iromie.setRepresentFirst();		iromie.drawCanvas(canvas);	}	/**	 * 「中央値フィルター」時の動作	 */	private void medianCommand() {		iromie.medianFilter();		iromie.setMedianPixels();		iromie.drawCanvas(canvas);	}	/**	 * 「４方向３×３ラプラシアンフィルター」時の動作	 */	private void laplacian34Command() {		iromie.setRepresentFirst();		iromie.laplacian34Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("４方向３×３ラプラシアン");	}	/**	 * 「８方向３×３ラプラシアンフィルター」時の動作	 */	private void laplacian38Command() {		iromie.setRepresentFirst();		iromie.laplacian38Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("８方向３×３ラプラシアン");	}	/**	 * 「８方向９×９ラプラシアンフィルター」時の動作	 */	private void laplacian98Command() {		iromie.setRepresentFirst();		iromie.laplacian98Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("８方向９×９ラプラシアン");	}	/**	 * 「４方向３×３ラプラシアン先鋭フィルター」時の動作	 */	private void acute34Command() {		iromie.setRepresentFirst();		iromie.acute34Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("４方向３×３先鋭");	}	/**	 * 「８方向３×３ラプラシアン先鋭フィルター」時の動作	 */	private void acute38Command() {		iromie.setRepresentFirst();		iromie.acute38Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("８方向３×３先鋭");	}	/**	 * 「８方向９×９ラプラシアン先鋭フィルター」時の動作	 */	private void acute98Command() {		iromie.setRepresentFirst();		iromie.acute98Filter();		iromie.setFilteredPixels();		iromie.drawCanvas("８方向９×９先鋭");	}		//------------------------------------------------------------------------------------------------		/************************************************************	 *						各種コマンド						*	 ************************************************************/		/**	 * 「Ｋクラスタリング」時の動作	 */	private void kClusteringCommand() {		if (!clickable) {			iromie.unificationClear();			for (int i=0;i<BUTTON_NUM;i++) {				selfLabel[i].setText("");				relationLabel[i].setText("");				button[i].setLabel("  ");			}			reprK = 0;			reprKVector = new IntVector();			clickable = true;		} else {			clickable = false;//同期は少し心配な部分			reprKInt = new int[reprK];			for (int i=0;i<reprK;i++) {				reprKInt[i] = ((Integer)(reprKVector.elementAt(i))).intValue();			}			iromie.kClustering(reprK, reprKInt, -1);			//Ｋクラスタリング後の画像を提示			iromie.setReducePixels();			iromie.drawCanvas(canvas);			//リソースの解放			reprKVector = null;			reprKInt = null;			/*			//領域の決定			iromie.autoDecidingAreas(reprK, 1);			//識別の自動判定設定			iromie.autoSetDistinguishGravity();			*/			setRepaintMenuItemsEnabled(true);		}	}	/**	 * 色盲変換コマンド。original の pixels か colorOBJ を色盲変換する。	 * @param dichromatType	 */	private void dichromatCommand(int dichromatType) {		iromie.dichromatConvertion(dichromatType);		if (iromie.colorUnificationBoolean) {			iromie.setRepresentFirstDichromat(dichromatType);		} else {			iromie.setFilteredPixels();		}		iromie.drawCanvas("第"+dichromatType+"色盲変換");	}	/**	 * 再配色の結果、num色のボタンを押したときの、num色のエネルギーを表示するコマンド	 * @param num 色番号	 */	private void buttonCommand(int num) {		if (iromie.colorUnificationBoolean) {			int colorOBJNum = iromie.getColorOBJNum();			if (!(num < colorOBJNum)) {				return;			}			for (int i=0;i<colorOBJNum;i++) {				relationLabel[i].setText(					"D:"+iromie.getDistinguishGravity()[num][i]					+". C:"+iromie.getContrastGravity()[num][i]);			}					}	}		//-----------------------------------------------------------------------------------------------		/************************************************************	 *				簡易実行シミュレーテッドアニーリング		*	 ************************************************************/		/**	 * Reset to state = 0	 * state -> 0 : STATE_TRICHROMATIC	 */	private void resetState() {		iromie.setRepresentFirst();		iromie.drawCanvas(canvas);		tetraPanel[1].removeAll();		tetraPanel[2].removeAll();		tetraPanel[3].removeAll();				state = STATE_TRICHROMATIC;//0		panelCenter.validate();	}	/**	 * draw the Dichromat of the Original on U-R	 * state -> (1, 2, or 3) : (STATE_PROTANOPE, STATE_DEUTERANOPE, or STATE_TRITANOPE)	 * @param num : Panel's and Label's number	 */	private void drawDichromatCommand(int num) {		if (state!=0) resetState();		tripleLabel[0].setText(Dichromat.typeString(num+1) + " View of the Original");		iromie.getDichroCanvas(num+1, tripleCanvas[0]);		tetraPanel[1].add(tripleLabel[0], BorderLayout.NORTH);		tetraPanel[1].add(tripleCanvas[0], BorderLayout.CENTER);		System.out.println("drawDichromatCommand("+num+")");				state = num + 1;		panelCenter.validate();	}	/**	 * draw Dichromat on U-R, Repaint on D-L, Repaint-Dichromat on U-R	 * state -> (4, 5, or 6) : (STATE_PROTANOPE_REPAINT, STATE_DEUTERANOPE_REPAINT, or STATE_TRITANOPE_REPAINT)	 * @param dichromatType	 */	private void drawRepaintSystemCommand(int type) {		if(state<1 && state>3) {			resetState();			// Dichromat View			tripleLabel[0].setText(Dichromat.typeString(type) + " Vew of the Original");			iromie.getDichroCanvas(type, tripleCanvas[0]);			tetraPanel[1].add(tripleLabel[0], BorderLayout.NORTH);			tetraPanel[1].add(tripleCanvas[0], BorderLayout.CENTER);						state = type;		}				// Repaint View		tripleLabel[1].setText("Repaint for " + Dichromat.typeString(type));		tripleLabel[2].setText(Dichromat.typeString(type) + " View of the Repaint");		drawRepaintAndRepaintDichromat(type, tripleCanvas[1], tripleCanvas[2]);		tetraPanel[2].add(tripleLabel[1], BorderLayout.NORTH);		tetraPanel[3].add(tripleLabel[2], BorderLayout.NORTH);		tetraPanel[2].add(tripleCanvas[1], BorderLayout.CENTER);		tetraPanel[3].add(tripleCanvas[2], BorderLayout.CENTER);		System.out.println("drawRepaintSystemCommand done.");				state = type + 3;		panelCenter.validate();	}		/**	 * draw Protanope on U-R, Deuteranope on D-L, Tritanope on U-R	 * state -> 7 : STATE_DICHROMAT	 */	private void drawAllTypeViewCommand() {		if (state != STATE_TRICHROMATIC) resetState();		for (int i=0;i<3;i++) {			tripleLabel[i].setText(Dichromat.typeString(i+1) + " View of the Original");			iromie.getDichroCanvas(i+1, tripleCanvas[i]);			tetraPanel[i+1].add(tripleLabel[i], BorderLayout.NORTH);			tetraPanel[i+1].add(tripleCanvas[i], BorderLayout.CENTER);		}		System.out.println("drawAllTypeViewCommand done.");				state = STATE_DICHROMAT;//7		panelCenter.validate();	}		/**	 * draw Repaint-for type viewed by	 *   Tritanope   on Up-Left,   Protanope on Up-Right,	 *   Deuteranope on Down-Left, Tritanope on Down-Right	 * state -> 8 : STATE_DICHROMAT_REPAINT	 * @param type	 */	private void drawAllTypeViewOfRepaintCommand(int type) {		if(state!=IromieGUI.STATE_DICHROMAT) return;		drawRepaintDichromat(type, canvas, tripleCanvas[0], tripleCanvas[1], tripleCanvas[2]);		for (int i=0;i<3;i++) {			tripleLabel[i].setText(					Dichromat.typeString(i+1) + " View of the Repaint for " + Dichromat.typeString(type));			tetraPanel[i+1].add(tripleLabel[i], BorderLayout.NORTH);			tetraPanel[i+1].add(tripleCanvas[i], BorderLayout.CENTER);		}		System.out.println("drawAllTypeViewOfRepaintCommand done.");				state = STATE_DICHROMAT_REPAINT;//8		panelCenter.validate();	}		/**	 * draw Repaint-for each-type viewed by each-type	 *   Original viewed by Original on Up-Left,        Repaint for Protanope viewed by Protanope,	 *   Repaint for Deuteranope viewed by Deuteranope, Repaint for Tritanope viewed bye Tritanope	 * state -> 9 : STATE_EACH_REPAINT	 */	private void drawEachTypeRepaintCommand() {		if (state != STATE_TRICHROMATIC) resetState();		for (int i=0;i<3;i++) {			tripleLabel[i].setText(Dichromat.typeString(i+1) + " View of the Repaint");			drawRepaintDichromat(i+1, tripleCanvas[i]);			tetraPanel[i+1].add(tripleLabel[i], BorderLayout.NORTH);			tetraPanel[i+1].add(tripleCanvas[i], BorderLayout.CENTER);		}		System.out.println("drawAllRepaintDichromatCommand done.");				state = STATE_EACH_REPAINT;//9		panelCenter.validate();	}		//---------------------------------------------------------------------------------------------		/************************************************************	 *					重要度設定ダイアログ					*	 ************************************************************/		/**	 * 重要度を操作するダイアログの実装　ただし、識別性とコントラストからのみ呼ばれる	 * @param dialog	 * @param gravity	 * @param colorNum	 */	private void gravityDialog(final JDialog dialog, final double[][] gravity, final int colorNum) {		final int[] focusNum = new int[1];		final double[][] tempG = new double[gravity.length][gravity[0].length];		for (int i=0;i<colorNum;i++) {			for (int j=0;j<colorNum;j++) {				tempG[i][j] = gravity[i][j];			}		}		Canvas[] dCanvas = new Canvas[colorNum];		Button[] dButton = new Button[colorNum];		final JScrollBar[] bar = new JScrollBar[colorNum];		final Label[] label = new Label[colorNum];		final TextField resetTf = new TextField("0");		dialog.getContentPane().setLayout(new GridLayout(colorNum+1,4));		for (int i=0;i<colorNum;i++) {			final int j = i;			dCanvas[j] = new Canvas();			dCanvas[j].setBackground(button[j].getBackground());			dCanvas[j].setForeground(button[j].getBackground());			dButton[j] = new Button("    ");			dButton[j].setBackground(button[j].getBackground());			bar[j] = new JScrollBar(JScrollBar.HORIZONTAL, (int)tempG[0][j], 1, 0, 1000);			label[j] = new Label(""+(int)tempG[0][j]);			dButton[j].addActionListener(new ActionListener() {				public void actionPerformed(ActionEvent ae) {					focusNum[0] = j;					for (int i=0;i<colorNum;i++) {						bar[i].setValue((int)tempG[focusNum[0]][i]);					}				}			});			bar[i].addAdjustmentListener(new AdjustmentListener() {				public void adjustmentValueChanged(AdjustmentEvent ae) {					tempG[focusNum[0]][j] = tempG[j][focusNum[0]] = (double)(ae.getValue());					label[j].setText(""+ae.getValue());				}			});			dialog.getContentPane().add(dCanvas[i]);			dialog.getContentPane().add(dButton[i]);			dialog.getContentPane().add(bar[i]);			dialog.getContentPane().add(label[i]);		}		Button okButton = new Button("OK");		Button resetButton = new Button("Reset");		okButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				for (int i=0;i<colorNum;i++) {					for (int j=0;j<colorNum;j++) {						if(i!=j) gravity[i][j] = tempG[i][j];					}				}				dialog.setVisible(false);			}		});		resetButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				String resetString = resetTf.getText();				int resetNum = Integer.parseInt(resetString);				for (int i=0;i<colorNum;i++) {					bar[i].setValue(resetNum);					label[i].setText(resetString);					for (int j=0;j<colorNum;j++) {						tempG[i][j] = resetNum;					}				}			}		});		dialog.getContentPane().add(okButton);		dialog.getContentPane().add(resetButton);		dialog.getContentPane().add(resetTf);		dialog.setSize(500, 30*colorNum+10);		dialog.setVisible(true);	}	/**	 * 識別性の重要度設定ダイアログ	 */	private void distinguishCommand() {		JDialog dialog = new JDialog(this, "識別の重要度設定", true);		int colorNum = iromie.getColorOBJNum();		double[][] disG = iromie.getDistinguishGravity();		gravityDialog(dialog, disG, colorNum);	}	/**	 * コントラストの重要度設定ダイアログ	 */	private void contrastCommand() {		JDialog dialog = new JDialog(this, "コントラストの重要度設定", true);		int colorNum = iromie.getColorOBJNum();		double[][] conG = iromie.getContrastGravity();		gravityDialog(dialog, conG, colorNum);	}	/**	 * 色の保存の重要度設定ダイアログ	 */	private void keepCommand() {		final JDialog dialog = new JDialog(this, "色の保存の重要度設定", true);		final int colorNum = iromie.getColorOBJNum();		final double[] kepG = iromie.getKeepGravity();		// final int[] focusNum = new int[1];		final double[] tempKepG = new double[kepG.length];		for (int i=0;i<colorNum;i++) {			tempKepG[i] = kepG[i];		}		Canvas[] dCanvas = new Canvas[colorNum];		Button[] dButton = new Button[colorNum];		final JScrollBar[] bar = new JScrollBar[colorNum];		final Label[] label = new Label[colorNum];		dialog.getContentPane().setLayout(new GridLayout(colorNum+1,4));		for (int i=0;i<colorNum;i++) {			final int j = i;			dCanvas[j] = new Canvas();			dCanvas[j].setBackground(button[j].getBackground());			dButton[j] = new Button("  ");			dButton[j].setBackground(button[j].getBackground());			bar[j] = new JScrollBar(JScrollBar.HORIZONTAL, (int)tempKepG[j], 1, 0, 1000);			label[j] = new Label(""+(int)tempKepG[j]);			bar[i].addAdjustmentListener(new AdjustmentListener() {				public void adjustmentValueChanged(AdjustmentEvent ae) {					tempKepG[j] = (double)(ae.getValue());					label[j].setText(""+ae.getValue());				}			});			dialog.getContentPane().add(dCanvas[i]);			dialog.getContentPane().add(dButton[i]);			dialog.getContentPane().add(bar[i]);			dialog.getContentPane().add(label[i]);		}		Button okButton = new Button("OK");		Button resetButton = new Button("Reset");		okButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				for (int i=0;i<colorNum;i++) {					kepG[i] = tempKepG[i];				}				dialog.setVisible(false);			}		});		resetButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				for (int i=0;i<colorNum;i++) {					bar[i].setValue(1);					label[i].setText("1");					kepG[i] = 1.0;				}			}		});		dialog.getContentPane().add(okButton);		dialog.getContentPane().add(resetButton);		dialog.setSize(500, 30*colorNum+10);		dialog.setVisible(true);		for (int i=0;i<colorNum;i++) {			SRGB srgb = iromie.getColorOBJ(i).getFirstSRGB();			selfLabel[i].setText("("+(int)255*srgb.getValue1()+", "+(int)255*srgb.getValue2()+", "+(int)255*srgb.getValue3()+")"				+" K:"+kepG[i]+" ");		}	}		/************************************************************	 *				シミュレーテッドアニーリング				*	 ************************************************************/		/**	 * This SimulatedAnnealing command is done, when SimulateAnnealing menu is selected.	 * @param dichromatType 	 */	private void simulatedAnnealingCommand(int dichromatType) {		// user can't do any other optimize-work		setRepaintMenuItemsEnabled(false);				final int dType = dichromatType;				// auto-setting Simulated Annealing parameter		// But, I don't know how can we decide these parameters.				// make SimulatedAnnealing window		final JDialog saDialog = new JDialog(this, "SimulatedAnnealing for "+Dichromat.typeString(dichromatType), false);		// these labels explain the SimulatedAnnealing parameters		Label[] nameLabel = new Label[10];		final TextField[] tf = new TextField[10];		Button saButton = new Button("SimulatedAnnealing");		Button closeButton = new Button("Close");		CheckboxGroup firstOptimizeGroup = new CheckboxGroup();		final Checkbox firstCheck = new Checkbox("元の色に対して", firstOptimizeGroup, true);		final Checkbox optimizedCheck = new Checkbox("現在最適化中の色に対して", firstOptimizeGroup, false);		final Label saMsgLabel = new Label("");				if (autoSetParameterForSimulatedAnnealing) {			iromie.setRepresentFirst();			iromie.simulatedAnnealing(dType);			iromie.setRepresentOptimized();			iromie.drawCanvas("第"+dType+"色盲のSA再配色を正常者から見た場合");			iromie.setRepresentOptimizedDichromat(dType);			iromie.drawCanvas("第"+dType+"色盲のSA再配色");			return;		}				// show default label and parameter		nameLabel[0] = new Label("最低に必要なループ回数");		tf[0] = new TextField("");		nameLabel[1] = new Label("十分小さい値");		tf[1] = new TextField(""+iromie.defE);		nameLabel[2] = new Label("初期ジャンプ距離");		tf[2] = new TextField(""+iromie.defJump);		nameLabel[3] = new Label("ジャンプ冷却倍率");		tf[3] = new TextField(""+iromie.defJumpCold);		nameLabel[4] = new Label("初期温度値");		tf[4] = new TextField(""+iromie.defTemperture);		nameLabel[5] = new Label("温度冷却倍率");		tf[5] = new TextField(""+iromie.defTempertureCold);		nameLabel[6] = new Label("試験ループ回数");		tf[6] = new TextField(""+iromie.testLoopMax);				// put the components		saDialog.getContentPane().setLayout(new GridLayout(9, 2));		saDialog.getContentPane().add(firstCheck);		saDialog.getContentPane().add(optimizedCheck);		for (int i=0;i<7;i++) {			saDialog.getContentPane().add(nameLabel[i]);			saDialog.getContentPane().add(tf[i]);		}				// This action calls SimulatedAnnealing, when the execute button is pressed.		saButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				if (optimizedCheck.getState() && iromie.getColorOBJ(0).getOptimizedSRGB()!=null)					iromie.setRepresentOptimized();				else					iromie.setRepresentFirst();								// do SimulatedAnnealing				try {					iromie.simulatedAnnealing(dType);				} catch (Exception e) {					saMsgLabel.setText("Please type here numbers."+e);					return; // false end				}								// the components setting				int n = iromie.getColorOBJNum();				Button[] b = new Button[n];				Label[] l = new Label[n];								// superL show SimulatedAnnealing parameters				Label[] superL = new Label[2];				superL[0] = new Label(); superL[1] = new Label();								// the result colors for painting buttons				SRGB[] srgb = new SRGB[n];								// have the color-to-color energy result				String[][] text = new String[n][n];								// set result to labels				superL[0].setText(					"D:"+(int)(iromie.sa.distinguishabilityEnergy())					+", C:"+(int)(iromie.sa.contrastEnergy()));				superL[1].setText(					", K:"+(int)(iromie.sa.keepabilityEnergy())					+", E:"+(int)(iromie.sa.energy()));								// get fine result-data				for (int i=0;i<n;i++) {					srgb[i] = iromie.getColorOBJ(i).getOptimizedDichromatSRGB(dType);					for (int j=0;j<n;j++) {						text[i][j] =							"D:"+(int)(iromie.sa.distinguishabilityEnergy(i,j))							+", C:"+(int)(iromie.sa.contrastEnergy(i,j))							+", K:"+(int)(iromie.sa.keepabilityEnergy(i))							+", dcΔ:"+(int)(iromie.sa.nowDichroLabs[i].getColorDistance76(iromie.sa.nowDichroLabs[j]))							+", idΔ:"+(int)((iromie.sa.compDesire).getContrastIdeal(i,j));					}				}								// make the color buttons				setButtonAndLabelAction(b, l, srgb, text);								// set draw color, and draw				iromie.setRepresentOptimized();				iromie.drawCanvas("第"+dType+"色盲のSA再配色を正常者から見た場合");				iromie.setRepresentOptimizedDichromat(dType);				iromie.drawCanvas("第"+dType+"色盲のSA再配色", b, l, superL);/*				// set parameters to labels				tf[0].setText("");				tf[1].setText(""+iromie.sa.epsilon);				tf[2].setText(""+iromie.sa.jump);				tf[3].setText(""+iromie.sa.jumpCold);				tf[4].setText(""+iromie.sa.t);				tf[5].setText(""+iromie.sa.tCold);*/				// make the after-optimized-menuItem clickable				optimizedCheck.setState(true);			}		});				// close event		closeButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				saDialog.setVisible(false);				// SimulatedAnnealing-Exit means user can do new optimize-work				setRepaintMenuItemsEnabled(true);			}		});		// close event		addWindowListener(new WindowAdapter(){			public void windowClosing(WindowEvent e){				saDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});				// component set		saDialog.getContentPane().add(saButton);		saDialog.getContentPane().add(closeButton);		saDialog.setSize(300,300);		saDialog.setVisible(true);	}		private void expSimulatedAnnealingCommand() {		// 他のメニューの実行を不許可		setRepaintMenuItemsEnabled(false);				// コンポーネント作成		final JDialog saDialog = new JDialog(this, "Simulated Annealing", false);		Button saButton = new Button("Execute");		Button closeButton = new Button("Close");				// 色盲タイプ　チェックボックス		// CheckboxGroup firstOptimizeGroup = new CheckboxGroup();		final Checkbox[] dichromatTypeCheck = new Checkbox[4];		CheckboxGroup dichroTypeGroup = new CheckboxGroup();		for (int i =0;i<4;i++) {			dichromatTypeCheck[i] = new Checkbox(""+Dichromat.typeString(i), dichroTypeGroup, false);		}				// コンポーネント　追加		saDialog.getContentPane().setLayout(new GridLayout(3, 2));		for (int i=0;i<4;i++) {			saDialog.getContentPane().add(dichromatTypeCheck[i]);		}				//実行ボタン動作		saButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				int dType;								// チェックボックスから、色盲タイプの入力				if (dichromatTypeCheck[0].getState()) dType = 0;				else if (dichromatTypeCheck[1].getState()) dType = 1;				else if (dichromatTypeCheck[2].getState()) dType = 2;				else dType = 3;								// SAの実行				int expID;				expID = iromie.sa(dType);								// 結果の表示				expPaint(expID, dType);			}		});				// 終了ボタン動作		closeButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				System.out.println("closeButton");				saDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// 閉じる動作		saDialog.addWindowListener(new WindowAdapter(){			public void windowClosing(WindowEvent e){				System.out.println("windowClosing");				saDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// ウィンドウ表示		saDialog.getContentPane().add(saButton);		saDialog.getContentPane().add(closeButton);		saDialog.setSize(300,300);		saDialog.setVisible(true);	}	/**	 * 正常者のためのSAコマンド	 * 簡単のため、ここでSAのパラメーターを直接指定している。	 * パラメーターの意味は順に以下。	 * double t0, int tStay, double tExit, double tCold,	 * double jump0, int jumpStay, double jumpCold	 */	private void trichromatSimulatedAnnealingCommand() {		int expID = iromie.trichromatSA(10000.0, 500, 1.0, 0.95, 10.0, 4, 0.5);		expPaint(expID, Dichromat.TRICHROMAT);	}	/************************************************************	 *						ニュートン法						*	 ************************************************************/			private void newtonRaphsonCommand() {		// 他のメニューの実行を不許可		setRepaintMenuItemsEnabled(false);				// コンポーネント作成		final JDialog nrDialog = new JDialog(this, "NewtonRaphson", false);		Button nrButton = new Button("Execute");		Button closeButton = new Button("Close");				// 色盲タイプ　チェックボックス		// CheckboxGroup firstOptimizeGroup = new CheckboxGroup();		final Checkbox[] dichromatTypeCheck = new Checkbox[4];		CheckboxGroup dichroTypeGroup = new CheckboxGroup();		for (int i =0;i<4;i++) {			dichromatTypeCheck[i] = new Checkbox(""+Dichromat.typeString(i), dichroTypeGroup, false);		}				// コンポーネント　追加		nrDialog.getContentPane().setLayout(new GridLayout(3, 2));		for (int i=0;i<4;i++) {			nrDialog.getContentPane().add(dichromatTypeCheck[i]);		}				//実行ボタン動作		nrButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				int dType;								// decide dichromat type, with using newtonRaphson window.				if (dichromatTypeCheck[0].getState()) dType = 0;				else if (dichromatTypeCheck[1].getState()) dType = 1;				else if (dichromatTypeCheck[2].getState()) dType = 2;				else dType = 3;								// ニュートン法の実行				int expID;				expID = iromie.newtonRaphson(dType);				System.out.println("newton execution ended");								// 結果の表示				newtonRepaint(expID, dType);			}		});				// 終了ボタン動作		closeButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				System.out.println("closeButton");				nrDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// 閉じる動作		nrDialog.addWindowListener(new WindowAdapter(){			public void windowClosing(WindowEvent e){				System.out.println("windowClosing");				nrDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// ウィンドウ表示		nrDialog.getContentPane().add(nrButton);		nrDialog.getContentPane().add(closeButton);		nrDialog.setSize(300,300);		nrDialog.setVisible(true);	}		private void roughSAandNewtonCommand() {		// 他のメニューの実行を不許可		setRepaintMenuItemsEnabled(false);				// コンポーネント作成		final JDialog nrDialog = new JDialog(this, "NewtonRaphson", false);		Button nrButton = new Button("Execute");		Button closeButton = new Button("Close");				// 色盲タイプ　チェックボックス		// CheckboxGroup firstOptimizeGroup = new CheckboxGroup();		final Checkbox[] dichromatTypeCheck = new Checkbox[4];		CheckboxGroup dichroTypeGroup = new CheckboxGroup();		for (int i =0;i<4;i++) {			dichromatTypeCheck[i] = new Checkbox(""+Dichromat.typeString(i), dichroTypeGroup, false);		}				// コンポーネント　追加		nrDialog.getContentPane().setLayout(new GridLayout(3, 2));		for (int i=0;i<4;i++) {			nrDialog.getContentPane().add(dichromatTypeCheck[i]);		}				//実行ボタン動作		nrButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				int dType;								// decide dichromat type, with using newtonRaphson window.				if (dichromatTypeCheck[0].getState()) dType = 0;				else if (dichromatTypeCheck[1].getState()) dType = 1;				else if (dichromatTypeCheck[2].getState()) dType = 2;				else dType = 3;								// ニュートン法の実行				int[] expID;				expID = iromie.roughSAandNewton(dType);				System.out.println("newton execution ended");								// 結果の表示				for(int i=0;i<expID.length;i++)					expPaint(expID[i], dType);			}		});				// 終了ボタン動作		closeButton.addActionListener(new ActionListener() {			public void actionPerformed(ActionEvent ae) {				System.out.println("closeButton");				nrDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// 閉じる動作		nrDialog.addWindowListener(new WindowAdapter(){			public void windowClosing(WindowEvent e){				System.out.println("windowClosing");				nrDialog.setVisible(false);				setRepaintMenuItemsEnabled(true);			}		});		// ウィンドウ表示		nrDialog.getContentPane().add(nrButton);		nrDialog.getContentPane().add(closeButton);		nrDialog.setSize(300,300);		nrDialog.setVisible(true);	}			private void expPaint(int expID, int dType) {		// コンポーネント作成		int n = iromie.getColorOBJNum();		Button[] b = new Button[n];		Label[] l = new Label[n];		Label[] superL = new Label[2];		Panel ePanel = new Panel();		superL[0] = new Label(); superL[1] = new Label();		//SRGB[] optSrgb = new SRGB[n];		SRGB[] optDichroSrgb = new SRGB[n];		String[][] text = new String[n][n];		for(int i=0;i<n;i++) {			//optSrgb[i] = new SRGB();			optDichroSrgb[i] = new SRGB();		}		// フレーム作成		JFrame optFrame = new JFrame("第"+dType+"色盲のNewton再配色"+expID);		optFrame.getContentPane().setLayout(new BorderLayout());		//BitmapCanvas optCanvas = iromie.getOptCanvas(expID, optSrgb);		BitmapCanvas optDichroCanvas = iromie.getOptDichroCanvas(expID, optDichroSrgb, dType);				//　テーブル作成		double[][] contTable = new double[n][n], distTable = new double[n][n];		double[] keepTable = new double[n];		double energy = iromie.getEnergy(expID, contTable, distTable, keepTable);				superL[0].setText("D:"+(int)(1) +", C:"+(int)(1));		superL[1].setText(", K:"+(int)(1) +", Energy:"+energy);		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) {				text[i][j] =					"D:"+(int)distTable[i][j] +", C:"+(int)contTable[i][j]+", K:"+(int)keepTable[j]					+", dcΔ:"+optDichroSrgb[i].getLab().getColorDistance76(optDichroSrgb[j].getLab())					+", idΔ:"+iromie.getContIdeal(expID, i, j);			}		}				// make the Colorful-Clickable-Buttons		setButtonAndLabelAction(b, l, optDichroSrgb, text);				ePanel.setLayout(new GridLayout(b.length+1, 2));		for (int i=0;i<b.length;i++) {			ePanel.add(b[i]);			ePanel.add(l[i]);		}		ePanel.add(superL[0]); ePanel.add(superL[1]);		optFrame.getContentPane().add(ePanel, BorderLayout.EAST);		optFrame.getContentPane().add(optDichroCanvas, BorderLayout.CENTER);		//optFrame.getContentPane().add(optDichroCanvas, BorderLayout.CENTER);		optFrame.setSize(optDichroCanvas.getW()+400+10, optDichroCanvas.getH()*2+30);		optFrame.addWindowListener(new WindowCloseListener(optFrame));		optFrame.setVisible(true);	}		// ニュートン法の実行結果の表示メソッド	private void newtonRepaint(int expID, int dType) {		// make result window's components		int n = iromie.getColorOBJNum();		Button[] b = new Button[n];		Label[] l = new Label[n];		Label[] superL = new Label[2];		Panel ePanel = new Panel();		superL[0] = new Label(); superL[1] = new Label();		SRGB[] optSrgb = new SRGB[n];		SRGB[] optDichroSrgb = new SRGB[n];		String[][] text = new String[n][n];		for(int i=0;i<n;i++) {			optSrgb[i] = new SRGB();			optDichroSrgb[i] = new SRGB();		}		JFrame optFrame = new JFrame("第"+dType+"色盲のNewton再配色"+expID);		optFrame.getContentPane().setLayout(new BorderLayout());		BitmapCanvas optCanvas = iromie.getOptCanvas(expID, optSrgb);		BitmapCanvas optDichroCanvas = iromie.getOptDichroCanvas(expID, optDichroSrgb, dType);				String[][] contS = new String[n][n], distS = new String[n][n];		String[] keepS = new String[n], penaltyS = new String[n], lineS = new String[n];		String energyS = iromie.getNewtonEnergy(expID, contS, distS, keepS, penaltyS, lineS);				//TODO newtonEnergy を表示しているが、本当のエネルギーも知りたいところ。		//TODO あと、なんだ。えーと、エネルギーの表示方法ももう少し考えろ、と。		superL[0].setText("D:"+(int)(1) +", C:"+(int)(1));		superL[1].setText(", K:"+(int)(1) +", NewtonE:"+energyS);		for (int i=0;i<n;i++) {			for (int j=0;j<n;j++) {				text[i][j] =					"D:"+distS[i][j] +", C:"+contS[i][j]					+", K:"+keepS[j] +", P:"+penaltyS[j] +", L:"+lineS[j]					+", dcΔ:"+optDichroSrgb[i].getLab().getColorDistance76(optDichroSrgb[j].getLab())					+", idΔ:"+iromie.getContIdeal(expID, i, j);			}		}				// make the Colorful-Clickable-Buttons		setButtonAndLabelAction(b, l, optSrgb, text);				ePanel.setLayout(new GridLayout(b.length+1, 2));		for (int i=0;i<b.length;i++) {			ePanel.add(b[i]);			ePanel.add(l[i]);		}		ePanel.add(superL[0]); ePanel.add(superL[1]);		optFrame.getContentPane().add(ePanel, BorderLayout.EAST);		optFrame.getContentPane().add(optCanvas, BorderLayout.CENTER);		optFrame.getContentPane().add(optDichroCanvas, BorderLayout.SOUTH);		optFrame.setSize(optCanvas.getW()+400+10, optCanvas.getH()*2+30);		optFrame.addWindowListener(new WindowCloseListener(optFrame));		optFrame.setVisible(true);	}	/**	 * SA をして結果の色盲画像をキャンバスに描画	 * @param type	 * @param canvas	 */	public void drawRepaintDichromat(int type, BitmapCanvas canvas) {		int expNum = iromie.sa(type);		int n = iromie.getColorOBJNum();		SRGB[] tempSRGB = new SRGB[n];		for(int i=0;i<n;i++) tempSRGB[i] = new SRGB();		iromie.getOptDichroCanvas(expNum, tempSRGB, type, canvas);	}	/**	 * SA をして結果の画像を、正常者と色盲ごとにキャンバスに描画	 * @param type	 * @param canvas	 * @param canvasP	 * @param canvasD	 * @param canvasT	 */	public void drawRepaintDichromat(int type, BitmapCanvas canvas, 			BitmapCanvas canvasP, BitmapCanvas canvasD, BitmapCanvas canvasT) {		int expNum = iromie.sa(type);		int n = iromie.getColorOBJNum();		SRGB[] tempSRGB = new SRGB[n];		for(int i=0;i<n;i++) tempSRGB[i] = new SRGB();		iromie.getOptCanvas(expNum, tempSRGB, canvas);		iromie.getOptDichroCanvas(expNum, tempSRGB, Dichromat.PROTANOPE, canvasP);		iromie.getOptDichroCanvas(expNum, tempSRGB, Dichromat.DEUTERANOPE, canvasD);		iromie.getOptDichroCanvas(expNum, tempSRGB, Dichromat.TRITANOPE, canvasT);	}	/**	 * SA をして結果の画像を、正常者と最適化された色盲タイプの２つのキャンバスに描画	 * @param type	 * @param c1	 * @param c2	 */	public void drawRepaintAndRepaintDichromat(int type, BitmapCanvas c1, BitmapCanvas c2) {		int expNum = iromie.sa(type);		int n = iromie.getColorOBJNum();		SRGB[] tempSRGB = new SRGB[n];		for(int i=0;i<n;i++) tempSRGB[i] = new SRGB();		iromie.getOptCanvas(expNum, tempSRGB ,c1);		iromie.getOptDichroCanvas(expNum, tempSRGB, type, c2);	}		/**	 * ボタンとラベルを、色とテキストをもとに設定する	 * @param b	 * @param label	 * @param srgb	 * @param text	 */	private void setButtonAndLabelAction(Button[] b, Label[] label, SRGB[] srgb, String[][] text) {		assert b.length == label.length;		final Label[] l = label;		final String[][] t = text;		for (int i=0;i<l.length;i++) {			b[i] = new Button();			l[i] = new Label("                                   ");			b[i].setBackground(new Color(srgb[i].getInt()));		}		for (int i=0;i<l.length;i++) {			final int j = i;			b[i].addActionListener(new ActionListener() {				public void actionPerformed(ActionEvent ae) {					for (int i=0;i<l.length;i++) {						l[i].setText(t[j][i]);					}				}			});		}	}		/**	 * フレームを閉じたときのイベント	 */	class WindowCloseListener extends WindowAdapter{		private Frame frame;		WindowCloseListener(Frame frame){			this.frame = frame;		}		public void windowClosing(WindowEvent e){			frame.setVisible(false);		}	}		//----------------------------------------------------------------------------------------------		/************************************************************	 *					実行可能メニューの管理					*	 ************************************************************/	/**	 * 色盲変換の対象となるイメージが読み込まれた時などに、	 * 変換ボタンを押せるようにする。	 * @param enabled	 */	private void setFilterMenuItemsEnabled(boolean enabled) {		medianItem.setEnabled(enabled);		laplacian34Item.setEnabled(enabled);		laplacian38Item.setEnabled(enabled);		laplacian98Item.setEnabled(enabled);		acute34Item.setEnabled(enabled);		acute38Item.setEnabled(enabled);		acute98Item.setEnabled(enabled);		kClusteringItem.setEnabled(enabled);	}	private void setDichromatMenuItemsEnabled(boolean enabled) {		proItem.setEnabled(enabled);		deuItem.setEnabled(enabled);		triItem.setEnabled(enabled);		dichroItem.setEnabled(enabled);	}	private void setRepaintMenuItemsEnabled(boolean enabled){		distinguishItem.setEnabled(enabled);		contrastItem.setEnabled(enabled);		keepItem.setEnabled(enabled);		saItemPro.setEnabled(enabled);		saItemDeu.setEnabled(enabled);		saItemTri.setEnabled(enabled);		saItemDichro.setEnabled(enabled);		saItemProView.setEnabled(enabled);		saItemDeuView.setEnabled(enabled);		saItemTriView.setEnabled(enabled);		newtonRaphsonItem.setEnabled(enabled);		roughSAandNewtonItem.setEnabled(enabled);		expSAItem.setEnabled(enabled);	}		//----------------------------------------------------------------------------------------------		/************************************************************	 *						メイン								*	 ************************************************************/		public static void main(String[] args) {		IromieGUI jframe = new IromieGUI();		jframe.setSize(DEFAULT_W,DEFAULT_H);		jframe.setVisible(true);	}}//----------------------------------------------------------------------------------------------