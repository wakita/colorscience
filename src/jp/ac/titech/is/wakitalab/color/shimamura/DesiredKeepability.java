/* * 作成日: 2004/07/02 */package jp.ac.titech.is.wakitalab.color.shimamura;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @author shinamu1 */public class DesiredKeepability implements SimpleDesire, Serializable {	int n, type;	Lab[] idealLabs;	LMS[] idealLMSs;	double[] gravity;	double[] gradBase = new double[2], gradSq = new double[2];	double[][] hesseBase = new double[2][2], hesseSq = new double[2][2];		public DesiredKeepability (Lab[] idealLabs, double[] gravity, int type) {		n = idealLabs.length;		this.type = type;		this.idealLabs = new Lab[n];		idealLMSs = new LMS[n];		this.gravity = new double[n];		for (int i=0;i<n;i++) {			this.idealLabs[i] = idealLabs[i];			idealLMSs[i] = new LMS(); idealLabs[i].getLMSnoIf(idealLMSs[i]);			this.gravity[i] = gravity[i];		}	}		public int dimension() {		return n;	}	/**	 * 重要度の加算	 * @param dk	 */	void plus(DesiredKeepability dk) {		assert dimension() == dk.dimension();		double gravity[] = new double[dimension()];		for (int i = 0; i < dimension(); i++)			gravity[i] = this.gravity[i] + dk.gravity[i];	}	void getIdeal(int c_i, Lab idealLab) {		for(int i=0;i<3;i++) idealLab.setValue(i, idealLabs[i].getValue(i));	}	/**	 * 重要度をコピーして返す	 * @return	 */	double[] getGravity() {		double[] gravityCopy = new double[n];		for (int i=0;i<n;i++) gravityCopy[i] = gravity[i];		return gravityCopy;	}	/**	 * 理想値をコピーして返す	 * @return	 */	Lab[] getIdealLab () {		Lab[] idealCopy = new Lab[n];		for (int i=0;i<n;i++) idealCopy[i] = idealLabs[i].copyLab();		return idealCopy;	}	LMS[] getIdealLMS() {		LMS[] idealCopy = new LMS[n];		for (int i=0;i<n;i++) idealCopy[i] = idealLMSs[i].copyLMS();		return idealCopy;	}		/************************************************************	 *****              Lab でのエネルギー計算          *********	 ************************************************************/			public double energy (Lab[] labs, int i) {		if (gravity[i] > 0.0) {			double delta = labs[i].getColorDistance76(idealLabs[i]);			return gravity[i] * delta * delta;		} else return 0.0;	}	public double energy(Lab[] labs) {		double energy = 0.0;		for(int i=0;i<n;i++)			energy += energy(labs, i);		return energy;	}	public double energy(Lab[] labs, double[] keepEnergyTable) {		double energy = 0.0;		for(int i=0;i<n;i++)			energy += keepEnergyTable[i] = energy(labs, i);		return energy;	}				/************************************************************	 * ニュートン法で色盲LMS配列を用いた擬似エネルギーの計算	*	 ************************************************************/			/**	 * 基本関数	 * @param dlmss	 * @param c_i	 * @return	 */	public double energyNewton(LMS[] dlmss, int c_i) {		if (gravity[c_i]>0.0) {			double delta = CompoundDesire.deltaDICHROLMS(dlmss[c_i], idealLMSs[c_i], type);			return gravity[c_i] * delta * delta;		} else return 0.0;	}	public double energyNewton(LMS[] dlmss) {		double energy = 0.0;		for (int i=0;i<n;i++) {			energy += energyNewton(dlmss, i);		}		return energy;	}	public double energyNewton(LMS[] dlmss, double[] keepEnergyTable) {		double energy = 0.0;		for (int i=0;i<n;i++) {			energy += keepEnergyTable[i] = energyNewton(dlmss, i);		}		return energy;	}		/**	 * 色c_i のエネルギーを計算する。	 * @param c_i	 * @param dlms	 * @return	 */	public double energyNewton(int c_i, LMS dlms) {		double delta = CompoundDesire.deltaDICHROLMS(dlms, idealLMSs[c_i], type);		return gravity[c_i] * delta * delta;	}			/************************************************************	 * ニュートン法で用いるgradとhesseとエネルギーを同時に計算  *	 ************************************************************/			/**	 * 色c_i に関する、エネルギーと微分と二次微分を計算する。	 * @param c_i	 * @param dlms	 * @param type	 * @param grad	 * @param hesse	 * @return	 */	public double energyGradHesse(int c_i, LMS dlms, int type,			double[] grad, double[][] hesse) {		double delta = CompoundDesire.getDerivative(dlms, idealLMSs[c_i], type, gradBase, gradSq, hesseBase, hesseSq);		for(int i=0;i<2;i++) {			grad[i] = gravity[c_i] * gradSq[i];			for(int j=0;j<2;j++)				hesse[i][j] = gravity[c_i] * hesseSq[i][j];		}		return gravity[c_i] * delta * delta;	}		/**	 * 読み込み	 * @param in	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void readObject(ObjectInputStream in) 	throws IOException, ClassNotFoundException{		n = in.readInt();		type = in.readInt();		gravity = (double[])in.readObject();	}		/**	 * 保存	 * @param out	 * @throws IOException	 * @throws ClassNotFoundException	 */	public void writeObject(ObjectOutputStream out)	throws IOException, ClassNotFoundException {		out.writeInt(n);		out.write(type);		out.writeObject(gravity);	}}