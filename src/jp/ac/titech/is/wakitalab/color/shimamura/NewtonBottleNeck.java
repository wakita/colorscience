/* * 作成日： 2005/11/16 * 失敗に終わる。 * 降下方向（ニュートン方向）が色盲平面外に飛んでいくので、 * 降下しない可能性が高いため、ボツになった。 */package jp.ac.titech.is.wakitalab.color.shimamura;/** * @author shinamu1 */public class NewtonBottleNeck {	double[][] color, ideal, gravity;		DichromatPlaneContrast dpc = new DichromatPlaneContrast(color, ideal);	}abstract class NewtonBottleNeckFunction {	abstract double function(double[] x, double[] y);	abstract void gradient(double[] x, double[] y, double[] grad);	abstract void hesse(double[] x, double[] y, double[][] hesse);	}class DichromatPlaneContrast{	private double[][] color, ideal;	int neckP=-1, fixP=-1;	double[] colorNeckP = new double[3], colorFixP = new double[3];	double powerDeltaCash=0, deltaCash=0;		DichromatPlaneContrast(double[][] color, double[][] ideal) {		this.color = (double[][])color.clone();		this.ideal = (double[][])ideal.clone();	}	double function(int neck, int fix) {		@SuppressWarnings("unused")		double			dl1=color[neck][0], da1=color[neck][1], db1=color[neck][2],			dl2=color[fix][0],  da2=color[fix][1],  db2=color[fix][2],			dcicj=ideal[neck][fix],			delta=delta(neck, fix), powerDelta=powerDelta(neck,fix);		return			powerDelta - 2 * dcicj * delta + Power(dl1 - dl2,2);	}	void gradient(int neck, int fix, double[] grad) {		assert color!=null&&ideal!=null&&grad!=null;		double			dl1=color[neck][0], da1=color[neck][1], db1=color[neck][2],			dl2=color[fix][0],  da2=color[fix][1],  db2=color[fix][2],			dcicj=ideal[neck][fix],			delta=delta(neck, fix);		grad[0] = 2*(dl1 - dl2)*(1 - dcicj/delta);		grad[1] = 2*(da1 - da2)*(1 - dcicj/delta);		grad[2] = 2*(db1 - db2)*(1 - dcicj/delta);	}	/**	 * 	 * @param neck	 * @param fix	 * @param hesse	 */	void hessse(int neck, int fix, double[][] hesse) {		assert color!=null&&ideal!=null&&hesse!=null;		double			dl1=color[neck][0], da1=color[neck][1], db1=color[neck][2],			dl2=color[fix][0],  da2=color[fix][1],  db2=color[fix][2],			dcicj=ideal[neck][fix],			delta3=Power3(delta(neck,fix));		hesse[0][0]=2 - (2*(Power(da1 - da2,2) + Power(db1 - db2,2))*dcicj) / delta3;		hesse[0][1]= (2*(da1 - da2)*dcicj*(dl1 - dl2))/delta3;		hesse[0][2]=(2*(db1 - db2)*dcicj*(dl1 - dl2))/delta3;		hesse[1][0]=(2*(da1 - da2)*dcicj*(dl1 - dl2))/delta3;		hesse[1][1]= 2 - (2*dcicj*(Power(db1 - db2,2) + Power(dl1 - dl2,2))) / delta3;		hesse[1][2]=(2*(da1 - da2)*(db1 - db2)*dcicj)/delta3;		hesse[2][0]=(2*(db1 - db2)*dcicj*(dl1 - dl2))/delta3;		hesse[2][1]=(2*(da1 - da2)*(db1 - db2)*dcicj)/delta3;		hesse[2][2]=2 - (2*dcicj*(Power(da1 - da2,2) + Power(dl1 - dl2,2))) / delta3;	}	double determinant(int neck, int fix){		assert color!=null&&ideal!=null;		@SuppressWarnings("unused")		double			dl1=color[neck][0], da1=color[neck][1], db1=color[neck][2],			dl2=color[fix][0],  da2=color[fix][1],  db2=color[fix][2],			dcicj=ideal[neck][fix],			delta=delta(neck,fix), powerDelta=powerDelta(neck,fix);		return 8 + 8*dcicj*(dcicj/powerDelta - 2/delta);	}	void inverse(int neck, int fix, double[][] inv){		double			dl1=color[neck][0], da1=color[neck][1], db1=color[neck][2],			dl2=color[fix][0],  da2=color[fix][1],  db2=color[fix][2],			dcicj=ideal[neck][fix],			delta=delta(neck, fix), powerDelta=powerDelta(neck,fix);		inv[0][0] = (1 + ((Power(da1 - da2,2) + Power(db1 - db2,2))*dcicj)/		        ((-dcicj + delta)*powerDelta))/2;		inv[0][1] = -((da1 - da2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*(dl1 - dl2)*			       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*			            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 			         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/			          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*			            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[0][2] = -((db1 - db2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*(dl1 - dl2)*		       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[1][0] = -((da1 - da2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*(dl1 - dl2)*		       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		          		Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[1][1] = (Power(da1,4) - 4*Power(da1,3)*da2 + Power(da2,4) + 		       4*da1*da2*dcicj*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) + 		       (Power(db1 - db2,2) + Power(dl1 - dl2,2))*(Power(db1 - db2,2) - 		          dcicj*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) + Power(dl1 - dl2,2)) - 		       2*da1*da2*(2*Power(da2,2) + 2*Power(db1 - db2,2) + Power(dcicj,2) + 2*Power(dl1 - dl2,2)) + 		       Power(da2,2)*(2*Power(db1 - db2,2) + dcicj*(dcicj - 		             2*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))) + 2*Power(dl1 - dl2,2)) + 		       Power(da1,2)*(6*Power(da2,2) + 2*Power(db1 - db2,2) + 		          dcicj*(dcicj - 2*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))) + 2*Power(dl1 - dl2,2)))*		     (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		          Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		       (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		        (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		          Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2)));		inv[1][2] =		    -((da1 - da2)*(db1 - db2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*		       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[2][0] =-((db1 - db2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*(dl1 - dl2)*		       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[2][1] =		    -((da1 - da2)*(db1 - db2)*dcicj*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*		       (dcicj/(Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - Power(dcicj,2) + Power(dl1 - dl2,2),2)) + 		         (Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dcicj,2) + Power(dl1 - dl2,2))/		          (2.*(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2))*		            Power(Power(da1 - da2,2) + Power(db1 - db2,2) - (dcicj + dl1 - dl2)*(dcicj - dl1 + dl2),2))));		inv[2][2] =		    (Power(da1,4) - 4*Power(da1,3)*da2 - Power(db1,2)*dcicj*		        Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) + 		       2*db1*db2*dcicj*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) - 		       Power(db2,2)*dcicj*Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) - 		       4*da1*da2*(Power(da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)) + 		       Power(Power(da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2),2) + 		       2*Power(da1,2)*(3*Power(da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))/		     (2.*(-dcicj + Sqrt(Power(da1 - da2,2) + Power(db1 - db2,2) + Power(dl1 - dl2,2)))*		       Power3(delta));	}	private double powerDelta(int neck, int fix) {		assert color!=null&&ideal!=null;		boolean cash = colorIsCashed(neck,fix);		if (cash) return powerDeltaCash;		double powerDelta = 0.0;		for (int i=0;i<3;i++) powerDelta += Power(color[neck][i]-color[fix][i]);		neckP=neck; fixP=fix;		for (int i=0;i<3;i++) { colorNeckP[i]=color[neck][i]; colorFixP[i]=color[fix][i];}		return powerDeltaCash = powerDelta;	}	private double delta(int neck, int fix) {		assert color!=null&&ideal!=null;		boolean cash = colorIsCashed(neck,fix);		if (cash) return deltaCash;		neckP=neck; fixP=fix;		for (int i=0;i<3;i++) { colorNeckP[i]=color[neck][i]; colorFixP[i]=color[fix][i];}		return 	deltaCash = Sqrt(powerDelta(neck, fix));	}	private boolean colorIsCashed(int neck, int fix) {		assert color!=null&&ideal!=null;		if (fix==fixP&&neck==neckP) {			for(int i=0;i<3;i++) {				if (color[neck][i]!=colorNeckP[i]||color[fix][i]!=colorFixP[i]) return false;			}		} else return false;		return true;	}	private static double Power(double x) { return x*x;}	private static double Power(double x, int two) { return x*x;}	private static double Power3(double x) { return x*x*x;}	private static double Sqrt(double x) { return Math.sqrt(x);}}