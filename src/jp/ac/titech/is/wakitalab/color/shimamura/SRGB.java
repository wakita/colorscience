/* * 作成日: 2003/11/16 * */package jp.ac.titech.is.wakitalab.color.shimamura;import java.awt.*;/** * @author shimaken * */public class SRGB extends Vector3D {		/*	 * 定数	 */			/**	 * SRGBからXYZを計算する時に使う行列。	 */	final static Matrix3X3 matrix_toXYZ =	new Matrix3X3 (0.3933, 0.3651, 0.1903,				   0.2123, 0.7010, 0.0858,				   0.0182, 0.1117, 0.9570);	               		final static Matrix3X3 matrix_toLMS =	new Matrix3X3 (0.07809396120354872, 0.19976190058738216, 0.02501878780182632,					0.028270061722312965, 0.20114275639704565, 0.03537110055882903,					0.002895740443918356, 0.017585683268365668, 0.1572371304771618);		/**	 * XYZ と SRGB の間のガンマ変換時の係数	 */	public final static double GAMMA = 2.2;	public final static int SRGBMAXint = 255;	public final static double SRGBMAX = SRGBMAXint;		/*	 * コンストラクター	 */			/**	 * デフォルトコンストラクター	 */	public SRGB () {		super();	}		/**	 * double 3つをとるコンストラクター	 */	public SRGB (double value1, double value2, double value3) {		super(value1, value2, value3);	}		/**	 * int 3つをとるコンストラクター	 */	public SRGB (int value1, int value2, int value3) {		super(value1/255.0, value2/255.0, value3/255.0);	}		/**	 * double 配列をとるコンストラクター	 */	public SRGB (double values[]) {		super(values);	}		/**	 * Vector3D をとるコンストラクター	 */	public SRGB (Vector3D v) {		super(v);	}		/**	 * int値　をとる　コンストラクター	 * @param srgbInt	 */	public SRGB (int srgbInt) {		super();		super.setInt(srgbInt);	}		/**	 * Colorクラスをとる　コンストラクター	 * @param color Colorクラス	 */	public SRGB (Color color) {		setValue1(((double)color.getRed())/SRGBMAX);		setValue2(((double)color.getGreen())/SRGBMAX);		setValue3(((double)color.getBlue())/SRGBMAX);	}			/*	 * メソッド	 */			/**	 * 自分と同じ内容をコピー	 */	public SRGB copySRGB() {		SRGB srgb = new SRGB((Vector3D)this);		return srgb;	}		/**	 * XYZ に変換する。	 * @return XYZ	 */	public XYZ getXYZ() {		XYZ xyz = new XYZ(			gammaRevise(getValue1()),			gammaRevise(getValue2()),			gammaRevise(getValue3()));		matrix_toXYZ.convertVector3D((Vector3D)xyz, (Vector3D)xyz);		return xyz;	}		/**	 * XYZ に変換する。メモリーを与えて素早く効率的に！	 * @param xyz	 * @param tempValues	 */	public void getXYZ(XYZ xyz) {		tempValues[0] = gammaRevise(getValue1());		tempValues[1] = gammaRevise(getValue2());		tempValues[2] = gammaRevise(getValue3());		matrix_toXYZ.convertDoubles(tempValues);		xyz.setValue(			tempValues[0],			tempValues[1],			tempValues[2]);	}		/**	 * RGB に変換する。	 * @author shimaken	 *	 */	public RGB getRGB() {		return getXYZ().getRGB();	}		/**	 * Lab に変換する。	 * @author shimaken	 *	 */	public Lab getLab() {		return getXYZ().getLab();	}		/**	 * Lab に変換する。メモリーを与えて素早く効率的に！	 * @param lab	 */	public void getLab(Lab lab) {		getXYZ(XYZ.tempXYZ);		XYZ.tempXYZ.getLab(lab);	}		/**	 * Luv1976 に変換する。	 * @return	 */	public Luv1976 getLuv1976() {		return getXYZ().getLuv1976();	}		/**	 * Luv1976 に変換する。メモリーを与えて素早く効率的に！	 * @param luv 変換した Luv1976 値	 * @param xyz	 * @param tempDoubles	 * @return	 */	public void getLuv1976(Luv1976 luv) {		getXYZ(XYZ.tempXYZ);		XYZ.tempXYZ.getLuv1976(luv);	}		/**	 * LMSに変換。	 * @return	 */	public LMS getLMS() {		return getXYZ().getLMS();	}	/**	 * LMSに変換。メモリーを与える。	 * @param returnLMS	 * @return	 */	public LMS getLMS(LMS returnLMS) {		getXYZ(XYZ.tempXYZ); 		XYZ.tempXYZ.getLMS(returnLMS);		return returnLMS;	}		/**	 * ガンマ変換をする(ガンマ補正)	 * @param value 変換前	 * @return 変換後	 */	public static double gammaRevise(double value) {		return Math.pow(value, SRGB.GAMMA);	}		/**	 * 境界補正。	 * SRGBの境界条件を使って、値を修正する。	 * @return 補正をしたかの真偽	 */	public boolean boundaryReviseOld() {		boolean isRevised = false;		double value1 = getValue1();		double value2 = getValue2();		double value3 = getValue3();		if (value1 > 1.0) {			setValue1(1.0);			isRevised = true;		} else if (value1 < 0.0) {			setValue1(0.0);			isRevised = true;		}		if (value2 > 1.0) {			setValue2(1.0);			isRevised = true;		} else if (value2 < 0.0) {			setValue2(0.0);			isRevised = true;		}		if (value3 > 1.0) {			setValue3(1.0);			isRevised = true;		} else if (value3 < 0.0) {			setValue3(0.0);			isRevised = true;		}		return isRevised;	}		/**	 * 境界補正。overした分を中心に向かって補正する。	 * @return isRevised	 */	public boolean boundaryRevise() {		boolean isRevised = false;		tempValues[0] = getValue1();		tempValues[1] = getValue2();		tempValues[2] = getValue3();		double overMax = 0.0, over = 0.0;		for (int i=0;i<3;i++) {			over = - tempValues[i];			if(over > overMax) {				overMax = over;				isRevised = true;			}			over = tempValues[i] - 1.0;			if(over > overMax) {				overMax = over;				isRevised = true;			}		}		if (isRevised) {			double scale = 0.5 / (overMax + 0.5);			for (int i=0;i<3;i++) setValue(i, (tempValues[i] - 0.5) * scale);		}		return isRevised;	}		/**	 * This makes this as SRGBdash (which is linear to XYZ) in srgb_dash.	 * @param srgb_dash	 */	public void getSRGBdash(SRGBdash srgb_dash) {		for (int i=0;i<3;i++) {			srgb_dash.setValue(i, gammaRevise(getValue(i)));		}	}		public String toString() {		return "("+(int)(255.0*getValue1())+", "+(int)(255.0*getValue2())+", "+(int)(255.0*getValue3())+")";	}}